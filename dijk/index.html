<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dijkstra's Algorithm Robustness Verification</title>
<style>
  :root {
    --bg: #ffffff;
    --surface: #f6f8fa;
    --surface2: #eef1f5;
    --border: #d1d9e0;
    --text: #1f2328;
    --text-dim: #656d76;
    --accent: #0969da;
    --accent2: #1a7f37;
    --accent3: #8250df;
    --code-bg: #f6f8fa;
    --tab-hover: #eef1f5;
    --highlight: #0969da1a;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
  }
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 24px 0 0;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .header-content {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 24px;
  }
  .header-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 4px;
  }
  .header-sub {
    color: var(--text-dim);
    font-size: 0.875rem;
    margin-bottom: 16px;
  }
  .tabs {
    display: flex;
    gap: 0;
  }
  .tab {
    padding: 10px 20px;
    cursor: pointer;
    color: var(--text-dim);
    font-size: 0.875rem;
    font-weight: 500;
    border-bottom: 2px solid transparent;
    transition: color 0.15s, border-color 0.15s, background 0.15s;
    user-select: none;
    border-radius: 6px 6px 0 0;
  }
  .tab:hover {
    color: var(--text);
    background: var(--tab-hover);
  }
  .tab.active {
    color: var(--text);
    border-bottom-color: var(--accent);
  }
  .tab .tab-icon { margin-right: 6px; }

  main {
    max-width: 1100px;
    margin: 0 auto;
    padding: 32px 24px 80px;
  }
  .panel { display: none; }
  .panel.active { display: block; }

  /* Markdown-rendered content */
  .content h1 { font-size: 1.75rem; margin: 32px 0 16px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
  .content h1:first-child { margin-top: 0; }
  .content h2 { font-size: 1.375rem; margin: 28px 0 12px; padding-bottom: 6px; border-bottom: 1px solid var(--border); color: var(--accent); }
  .content h3 { font-size: 1.1rem; margin: 20px 0 8px; color: var(--accent3); }
  .content h4 { font-size: 1rem; margin: 16px 0 8px; color: var(--text-dim); }
  .content p { margin: 12px 0; }
  .content strong { color: #1f2328; }
  .content blockquote {
    border-left: 3px solid var(--accent);
    padding: 8px 16px;
    margin: 12px 0;
    background: var(--surface);
    border-radius: 0 6px 6px 0;
    color: var(--text-dim);
  }
  .content ul, .content ol { margin: 8px 0 8px 24px; }
  .content li { margin: 4px 0; }
  .content hr { border: none; border-top: 1px solid var(--border); margin: 24px 0; }
  .content a { color: var(--accent); text-decoration: none; }
  .content a:hover { text-decoration: underline; }
  .content table {
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
    font-size: 0.875rem;
  }
  .content table th {
    text-align: left;
    padding: 10px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    font-weight: 600;
    color: var(--accent);
  }
  .content table td {
    padding: 8px 14px;
    border: 1px solid var(--border);
  }
  .content table tr:hover td {
    background: var(--surface);
  }
  .content code {
    font-family: 'SF Mono', 'Fira Code', 'Fira Mono', Menlo, Consolas, monospace;
    background: var(--surface2);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.85em;
    color: var(--accent3);
  }
  .content pre {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px 20px;
    overflow-x: auto;
    margin: 16px 0;
    position: relative;
  }
  .content pre code {
    background: none;
    padding: 0;
    border-radius: 0;
    font-size: 0.8125rem;
    color: var(--text);
    line-height: 1.5;
  }

  /* Source code panel */
  .source-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  .source-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: var(--surface2);
    border-bottom: 1px solid var(--border);
    font-size: 0.8125rem;
    color: var(--text-dim);
  }
  .source-filename {
    font-family: 'SF Mono', Menlo, Consolas, monospace;
    color: var(--text);
    font-weight: 500;
  }
  .source-lines {
    display: flex;
    overflow-x: auto;
    font-family: 'SF Mono', 'Fira Code', Menlo, Consolas, monospace;
    font-size: 0.8125rem;
    line-height: 1.6;
  }
  .line-numbers {
    padding: 16px 0;
    text-align: right;
    color: var(--text-dim);
    user-select: none;
    min-width: 48px;
    opacity: 0.5;
    border-right: 1px solid var(--border);
  }
  .line-numbers span {
    display: block;
    padding: 0 12px;
  }
  .source-code {
    padding: 16px;
    flex: 1;
    white-space: pre;
    color: var(--text);
  }
  .source-code .comment { color: #6a737d; font-style: italic; }
  .source-code .keyword { color: #cf222e; }
  .source-code .predicate { color: #0550ae; }
  .source-code .operator { color: #8250df; }
  .source-code .bool { color: #1a7f37; }
  .source-code .number { color: #953800; }

  /* Copy button */
  .copy-btn {
    background: var(--surface);
    color: var(--text-dim);
    border: 1px solid var(--border);
    padding: 4px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.15s;
  }
  .copy-btn:hover { color: var(--text); background: var(--tab-hover); }

  /* Info boxes */
  .info-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent);
    border-radius: 0 6px 6px 0;
    padding: 16px 20px;
    margin: 20px 0;
  }
  .info-box.success { border-left-color: var(--accent2); }
  .info-box.purple { border-left-color: var(--accent3); }

  /* Top navigation */
  .topnav { border-bottom: 1px solid var(--border); font-size: 0.8rem; }
  .topnav-content {
    max-width: 1100px; margin: 0 auto; padding: 0 24px;
    display: flex; align-items: center; gap: 2px; flex-wrap: wrap;
  }
  .topnav-home {
    color: var(--accent); text-decoration: none; font-weight: 500;
    padding: 8px 0; white-space: nowrap; margin-right: 8px;
  }
  .topnav-home:hover { text-decoration: underline; }
  .nav-group { position: relative; }
  .nav-group-btn {
    background: none; border: none; cursor: pointer;
    color: var(--text-dim); font-size: 0.8rem; padding: 8px 12px;
    border-radius: 4px; font-family: inherit;
    transition: color 0.15s, background 0.15s;
  }
  .nav-group-btn:hover, .nav-group:focus-within .nav-group-btn {
    color: var(--text); background: var(--surface2);
  }
  .nav-group-btn.active { color: var(--text); font-weight: 600; }
  .nav-dropdown {
    display: none; position: absolute; top: 100%; left: 0;
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 6px; padding: 4px 0; min-width: 160px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 200;
  }
  .nav-group:hover .nav-dropdown,
  .nav-group:focus-within .nav-dropdown { display: block; }
  .nav-dropdown a {
    display: block; padding: 6px 16px; color: var(--text-dim);
    text-decoration: none; white-space: nowrap;
    transition: background 0.1s, color 0.1s;
  }
  .nav-dropdown a:hover { background: var(--surface); color: var(--text); }
  .nav-dropdown a.active { color: var(--accent); font-weight: 600; background: var(--highlight); }

  /* Responsive */
  @media (max-width: 768px) {
    .tab { padding: 8px 12px; font-size: 0.8rem; }
    main { padding: 20px 16px 60px; }
    .header-title { font-size: 1.25rem; }
  }
</style>
</head>
<body>

<header>
  <div class="topnav">
    <div class="topnav-content">
      <a href="../" class="topnav-home">&larr; All Examples</a>
      <div class="nav-group">
        <button class="nav-group-btn active">Robustness &#9662;</button>
        <div class="nav-dropdown">
          <a href="../isort/">Insertion Sort</a>
          <a href="../kruskal/">Kruskal</a>
          <a href="../dijk/" class="active">Dijkstra</a>
          <a href="../arraymax-robust/">ArrayMax</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Sensitivity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../histogram/">Histogram</a>
          <a href="../cdf/">CDF</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Monotonicity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../arraymax/">ArrayMax</a>
          <a href="../arraysum/">ArraySum</a>
          <a href="../kruskal-mono/">Kruskal</a>
          <a href="../arraysum-qmono/">ArraySum (Quant.)</a>
          <a href="../dijk-mono/">Dijkstra (vacuous)</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Commutativity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../commutativity/">ArraySum</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Cost &#9662;</button>
        <div class="nav-dropdown">
          <a href="../countpositive/">CountPositive</a>
          <a href="../cost-ext/">Extensions</a>
        </div>
      </div>
    </div>
  </div>
  <div class="header-content">
    <div class="header-title">Dijkstra's Algorithm Robustness Verification</div>
    <div class="header-sub">Relational Cell Morphing with PCSAT &mdash; (N-1)-Robustness Proof</div>
    <div class="tabs">
      <div class="tab active" data-panel="simple" onclick="switchTab(this)">
        <span class="tab-icon">&#128196;</span>Overview
      </div>
      <div class="tab" data-panel="detailed" onclick="switchTab(this)">
        <span class="tab-icon">&#128214;</span>Detailed Tutorial
      </div>
      <div class="tab" data-panel="source" onclick="switchTab(this)">
        <span class="tab-icon">&#128187;</span>Source Code
      </div>
    </div>
  </div>
</header>

<main>
  <!-- ============ SIMPLE / OVERVIEW PANEL ============ -->
  <div id="panel-simple" class="panel active content">
    <h1>Dijkstra's Algorithm Robustness Verification with PCSAT</h1>
    <p>A concise tutorial on verifying (N-1)-robustness using relational cell morphing.</p>
    <hr>

    <h2>The Algorithm</h2>
<pre><code>Dijkstra(G, src)
    for each v in G: d[v] := &infin;
    d[src] := 0
    WL := all nodes
    while WL &ne; &empty;:
        u := argmin d[v] for v in WL
        remove u from WL
        for each neighbor v of u:
            if d[u] + G[u,v] &lt; d[v]:
                d[v] := d[u] + G[u,v]
    return d</code></pre>
    <p><strong>Key observation</strong>: Distances are <strong>accumulated</strong> via edge weights. The value <code>d[v]</code> is the sum of edge weights along the shortest path &mdash; each edge contributes to the total.</p>
    <hr>

    <h2>The Property: (N-1)-Robustness</h2>
<pre><code>&forall;e. |G1[e] - G2[e]| &le; &epsilon;  &rArr;  &forall;v. |d1[v] - d2[v]| &le; (N-1)&middot;&epsilon;
     ~~~~~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~~~~~~~~~~~
     INPUT edge weights       OUTPUT distances</code></pre>
    <p><strong>In plain English</strong>: If two graphs have edge weights differing by at most &epsilon;, the shortest distances to any vertex differ by at most (N-1)&middot;&epsilon;.</p>
    <p><strong>Why "(N-1)-robust"?</strong> A shortest path has at most N-1 edges. Each edge contributes &le; &epsilon; to the difference, so the bound grows <strong>linearly</strong> with path length.</p>
    <hr>

    <h2>The Solution: Two Distinguished Cells</h2>
    <h3>The Problem</h3>
    <p>We need to verify a property about <strong>all vertices and edges</strong>, but CHC solvers can't handle quantified array properties directly.</p>

    <h3>The Solution: Two Symbolic Cells</h3>
    <p>Unlike insertion sort (one cell), Dijkstra requires <strong>two distinguished cells</strong>:</p>

    <h4>INPUT Cell (Edge Weight)</h4>
<pre><code>k:        Distinguished edge index (symbolic, universally quantified)
wk1, wk2: Weights G1[k], G2[k]
bk:       Sign bit for |wk1 - wk2|

PRECONDITION: |wk1 - wk2| &le; &epsilon;
INVARIANT: wk1, wk2 NEVER CHANGE (input constants)</code></pre>

    <h4>OUTPUT Cell (Vertex Distance)</h4>
<pre><code>v:        Distinguished vertex (implicit, symbolic)
dv1, dv2: Distances d1[v], d2[v]
bv:       Sign bit for |dv1 - dv2|

POSTCONDITION: |dv1 - dv2| &le; (N-1)&middot;&epsilon;
dv1, dv2 CAN CHANGE during relaxation</code></pre>
    <p><strong>Key insight</strong>: The INPUT cell never changes (edge weights are constants), while the OUTPUT cell is updated during relaxation steps.</p>
    <hr>

    <h2>Hop Count Abstraction</h2>
    <p>Unlike Kruskal where we can make HIT explicit (<code>c1' = c1 + wk1</code>), Dijkstra replaces distances via relaxation (<code>d[v] = d[u] + w</code>). We don't track <code>d[u]</code>, so we abstract via <strong>hop count</strong>:</p>
<pre><code>Each edge on the path contributes &le; &epsilon; to |dv1 - dv2|
Path has h edges
Therefore: |dv1 - dv2| &le; h &middot; &epsilon;

This works for BOTH HIT and MISS:
  - HIT:  edge k contributes |wk1 - wk2| &le; &epsilon;
  - MISS: other edge contributes &le; &epsilon; (by input assumption)</code></pre>
    <hr>

    <h2>HIT/MISS Abstraction</h2>
    <p>Comparing Dijkstra's approach to other algorithms:</p>
    <table>
      <thead>
        <tr><th>Algorithm</th><th>HIT Case</th><th>MISS Case</th></tr>
      </thead>
      <tbody>
        <tr><td><strong>Insertion Sort</strong></td><td><code>key1' = ak1</code> (explicit)</td><td><code>key1' = ???</code> (unknown)</td></tr>
        <tr><td><strong>Kruskal</strong></td><td><code>c1' = c1 + wk1</code> (explicit)</td><td><code>c1' = c1 + ???</code> (unknown)</td></tr>
        <tr><td><strong>Dijkstra</strong></td><td colspan="2">Both abstracted to hop count (&le; &epsilon; per edge)</td></tr>
      </tbody>
    </table>
    <div class="info-box">
      <strong>WHY DIJKSTRA'S HIT IS ABSTRACTED</strong><br><br>
      In Dijkstra: <code>d[v] = d[u] + G[e]</code><br><br>
      To make HIT explicit, we'd need: <code>dv1' = d1[u] + wk1</code><br>
      But we don't track <code>d1[u]</code> (predecessor's distance)!<br><br>
      <strong>Solution</strong>: Abstract to hop count. Each edge contributes &le; &epsilon;, so <code>|dv1 - dv2| &le; h &middot; &epsilon;</code>.
    </div>
    <hr>

    <h2>State Variables</h2>
<pre><code>Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps)</code></pre>
    <table>
      <thead>
        <tr><th>Variable</th><th>Meaning</th><th>Changes?</th></tr>
      </thead>
      <tbody>
        <tr><td><code>i1, i2</code></td><td>Iteration counter</td><td>Yes</td></tr>
        <tr><td><code>h1, h2</code></td><td><strong>Hop count</strong> (edges in shortest path to v)</td><td>Yes</td></tr>
        <tr><td><code>k</code></td><td>Distinguished edge index (symbolic)</td><td>Never</td></tr>
        <tr><td><code>wk1, wk2</code></td><td>Edge weights G1[k], G2[k]</td><td>Never</td></tr>
        <tr><td><code>bk</code></td><td>Sign bit for |wk1 - wk2|</td><td>Never</td></tr>
        <tr><td><code>dv1, dv2</code></td><td>Distances to distinguished vertex v</td><td>Yes</td></tr>
        <tr><td><code>bv</code></td><td>Sign bit for |dv1 - dv2|</td><td>Yes</td></tr>
        <tr><td><code>n, eps</code></td><td>Parameters (vertex count, perturbation bound)</td><td>Never</td></tr>
      </tbody>
    </table>
    <p><strong>Key</strong>: The bound uses <strong>hop count</strong> <code>h</code>, not iteration count <code>i</code>!</p>
    <hr>

    <h2>Why (N-1)-Robust Works</h2>
    <div class="info-box success">
      <strong>THE (N-1)-ROBUSTNESS INSIGHT</strong><br><br>
      <strong>INVARIANT:</strong> <code>|dv1 - dv2| &le; max(h1, h2) &middot; &epsilon;</code><br><br>
      Each relaxation step either:
      <ol style="margin:8px 0 8px 24px">
        <li>Leaves the distance unchanged (no relaxation needed)</li>
        <li>Replaces with a new shortest path of h edges, each contributing &le; &epsilon;</li>
        <li>Stutters at termination (algorithm finished)</li>
      </ol>
      Since <code>h &le; N-1</code> always, at termination: <code>|dv1 - dv2| &le; (N-1) &middot; &epsilon;</code><br><br>
      <code>INPUT: |wk1 - wk2| &le; &epsilon;</code> &rarr; <code>OUTPUT: |dv1 - dv2| &le; (N-1)&middot;&epsilon;</code>
    </div>
    <p>The bound uses <code>max(h1, h2)</code> because the longer path has more accumulated error:</p>
<pre><code>Run 1: path with h1 edges &rarr; accumulated error &le; h1&middot;&epsilon;
Run 2: path with h2 edges &rarr; accumulated error &le; h2&middot;&epsilon;

The longer path has more potential error.
So: |dv1 - dv2| &le; max(h1, h2) &middot; &epsilon;</code></pre>
    <hr>

    <h2>Verification Results</h2>
    <table>
      <thead>
        <tr><th>Goal Clause</th><th>Result</th><th>Time</th><th>Meaning</th></tr>
      </thead>
      <tbody>
        <tr><td><code>|dv1 - dv2| &le; (n-1)*eps</code></td><td><strong>SAT</strong></td><td>~1 min</td><td>Bound CAN be satisfied &check;</td></tr>
        <tr><td><code>|dv1 - dv2| &gt; (n-1)*eps</code></td><td><strong>UNSAT</strong></td><td>~5 min</td><td>Bound CANNOT be violated &check;</td></tr>
        <tr><td><code>dv1 = dv2</code></td><td><strong>UNSAT</strong></td><td>&mdash;</td><td>Exact equality too strong &check;</td></tr>
        <tr><td><code>|dv1 - dv2| &gt; eps</code> (1-robust)</td><td><strong>SAT</strong></td><td>&mdash;</td><td>1-robustness does NOT hold &check;</td></tr>
      </tbody>
    </table>

    <div class="info-box success">
      <strong>VERIFICATION COMPLETE</strong><br><br>
      <strong>Property:</strong> (N-1)-Robustness of Dijkstra's Algorithm<br>
      <strong>Statement:</strong> &forall;e. |G1[e] - G2[e]| &le; &epsilon; &rArr; &forall;v. |d1[v] - d2[v]| &le; (N-1)&middot;&epsilon;<br>
      <strong>Result:</strong> VERIFIED &check;<br>
      <strong>Evidence:</strong> Violation query returns UNSAT (no counterexample exists)
    </div>
    <hr>

    <h2>Key Takeaways</h2>
    <ol>
      <li><strong>Two Distinguished Cells</strong>: INPUT cell (edge weight, never changes) and OUTPUT cell (vertex distance, updated by relaxation). This separates the perturbation source from the accumulated effect.</li>
      <li><strong>Hop Count Abstraction</strong>: Use path length <code>h</code> (not iteration count <code>i</code>) to bound the difference. Each edge contributes &le; &epsilon;, so <code>|dv1 - dv2| &le; h&middot;&epsilon;</code>.</li>
      <li><strong>HIT/MISS Merged</strong>: Both HIT and MISS contribute &le; &epsilon; per edge, so they are merged into a single relaxation case. This simplifies the encoding compared to Kruskal.</li>
      <li><strong>Use max(h1, h2)</strong>: The longer path determines the worst-case accumulated error.</li>
      <li><strong>PCSAT Goal Interpretation</strong>: Positive property SAT &rarr; achievable &check;; Violation UNSAT &rarr; verified &check;</li>
    </ol>
    <hr>

    <h2>Comparison: Dijkstra vs Insertion Sort vs Kruskal</h2>
    <table>
      <thead>
        <tr><th>Aspect</th><th>Insertion Sort</th><th>Kruskal</th><th>Dijkstra</th></tr>
      </thead>
      <tbody>
        <tr><td><strong>Robustness</strong></td><td>1-robust</td><td>(N-1)-robust</td><td>(N-1)-robust</td></tr>
        <tr><td><strong>INPUT cell</strong></td><td>Array element</td><td>Edge weight</td><td>Edge weight</td></tr>
        <tr><td><strong>OUTPUT cell</strong></td><td>Same as input</td><td>MST cost</td><td>Vertex distance</td></tr>
        <tr><td><strong>HIT case</strong></td><td><code>key1' = ak1</code> (explicit)</td><td><code>c1' = c1 + wk1</code> (explicit)</td><td>Abstracted to hop count</td></tr>
        <tr><td><strong>Key invariant</strong></td><td><code>|ak1-ak2| &le; &epsilon;</code></td><td><code>|c1-c2| &le; i&middot;&epsilon;</code></td><td><code>|dv1-dv2| &le; h&middot;&epsilon;</code></td></tr>
        <tr><td><strong>Final bound</strong></td><td>&epsilon;</td><td>(N-1)&middot;&epsilon;</td><td>(N-1)&middot;&epsilon;</td></tr>
        <tr><td><strong>wk1/wk2 in transitions?</strong></td><td>N/A</td><td>Yes (in cost)</td><td>No (abstracted)</td></tr>
      </tbody>
    </table>
  </div>

  <!-- ============ DETAILED TUTORIAL PANEL ============ -->
  <div id="panel-detailed" class="panel content">
    <h1>Dijkstra's Algorithm Robustness Verification using PCSAT</h1>
    <h3>A Complete Tutorial on Relational Cell Morphing</h3>
    <hr>

    <h2>Overview</h2>
    <p>This document explains how to verify that <strong>Dijkstra's shortest-path algorithm</strong> is <strong>(N-1)-robust</strong> using <strong>PCSAT</strong> (a solver for predicate constraint satisfaction problems) with the <strong>relational cell morphing</strong> technique.</p>
    <h3>What You Will Learn</h3>
    <ul>
      <li>How to encode graph algorithms for robustness verification</li>
      <li>The two-distinguished-cell pattern (INPUT cell + OUTPUT cell)</li>
      <li>The hop count abstraction for bounding accumulated error</li>
      <li>Why Dijkstra's HIT/MISS is abstracted (unlike Kruskal's explicit HIT)</li>
      <li>How to interpret PCSAT verification results</li>
    </ul>
    <h3>Prerequisites</h3>
    <ul>
      <li>Basic understanding of Dijkstra's shortest-path algorithm</li>
      <li>Familiarity with the relational cell morphing technique (see Insertion Sort tutorial)</li>
      <li>Basic knowledge of formal verification concepts</li>
    </ul>
    <hr>

    <h2>The Algorithm</h2>
<pre><code>Dijkstra(G, src)
    for each v in G: d[v] := &infin;
    d[src] := 0
    WL := all nodes
    while WL &ne; &empty;:
        u := argmin d[v] for v in WL
        remove u from WL
        for each neighbor v of u:
            if d[u] + G[u,v] &lt; d[v]:
                d[v] := d[u] + G[u,v]
    return d</code></pre>

    <h3>Algorithm Visualization</h3>
<pre><code>Graph:
    A --2-- B --3-- D
    |               |
    4               1
    |               |
    C ------5------ E

Dijkstra from A:
  Step 1: d[A]=0, process A. Relax: d[B]=2, d[C]=4
  Step 2: d[B]=2, process B. Relax: d[D]=5
  Step 3: d[C]=4, process C. Relax: d[E]=9
  Step 4: d[D]=5, process D. Relax: d[E]=min(9,6)=6
  Step 5: d[E]=6, process E. Done.

Final: d[A]=0, d[B]=2, d[C]=4, d[D]=5, d[E]=6</code></pre>

    <h3>Key Observation</h3>
    <p><strong>Distances are ACCUMULATED via edge weights.</strong> The distance <code>d[v]</code> is the sum of edge weights along the shortest path. Each edge contributes to the total &mdash; this is why the robustness bound grows linearly with path length, making Dijkstra <strong>(N-1)-robust</strong> (not 1-robust like insertion sort).</p>
    <hr>

    <h2>The Property: (N-1)-Robustness</h2>
    <h3>Formal Definition</h3>
<pre><code>&forall;e. |G1[e] - G2[e]| &le; &epsilon;  &rArr;  &forall;v. |d1[v] - d2[v]| &le; (N-1)&middot;&epsilon;
     ~~~~~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~~~~~~~~~~~
     INPUT edge weights       OUTPUT distances</code></pre>

    <h3>In Plain English</h3>
    <blockquote>If two graphs have edge weights that differ by at most &epsilon;, then the shortest distances computed by Dijkstra differ by at most (N-1)&middot;&epsilon; for every vertex.</blockquote>

    <h3>Example</h3>
<pre><code>Graph G1:  A --2.0-- B --3.0-- C
Graph G2:  A --2.1-- B --2.9-- C    (each edge differs by &le; 0.1)

Dijkstra on G1: d1[C] = 2.0 + 3.0 = 5.0
Dijkstra on G2: d2[C] = 2.1 + 2.9 = 5.0

|d1[C] - d2[C]| = 0.0 &le; (3-1) &middot; 0.1 = 0.2  &check;

Worst case: all edges shift in same direction
Graph G1:  A --2.0-- B --3.0-- C
Graph G2:  A --2.1-- B --3.1-- C

d1[C] = 5.0, d2[C] = 5.2
|d1[C] - d2[C]| = 0.2 &le; (3-1) &middot; 0.1 = 0.2  &check; (tight!)</code></pre>

    <h3>Why "(N-1)-Robust"?</h3>
    <p>The bound grows <strong>linearly</strong> with N because a shortest path uses at most N-1 edges.</p>
    <table>
      <thead><tr><th>Algorithm</th><th>Robustness</th><th>Final Bound</th></tr></thead>
      <tbody>
        <tr><td>Insertion Sort</td><td>1-robust</td><td>&epsilon;</td></tr>
        <tr><td>Kruskal MST</td><td>(N-1)-robust</td><td>(N-1)&middot;&epsilon;</td></tr>
        <tr><td>Dijkstra</td><td>(N-1)-robust</td><td>(N-1)&middot;&epsilon;</td></tr>
      </tbody>
    </table>
    <hr>

    <h2>The Challenge: Two Types of Arrays</h2>
    <h3>The Problem</h3>
    <p>To verify (N-1)-robustness, we need to reason about:</p>
    <ul>
      <li><strong>Edge weights</strong> (input): <code>&forall;e. |G1[e] - G2[e]| &le; &epsilon;</code></li>
      <li><strong>Vertex distances</strong> (output): <code>&forall;v. |d1[v] - d2[v]| &le; (N-1)&middot;&epsilon;</code></li>
    </ul>
    <p><strong>CHC solvers cannot handle quantified array properties directly!</strong></p>

    <h3>Why This Is Harder Than Insertion Sort</h3>
<pre><code>Insertion Sort: ONE array, values only MOVE
  &rarr; One distinguished cell suffices

Dijkstra: TWO arrays (edges + distances), values ACCUMULATE
  &rarr; Need TWO distinguished cells
  &rarr; Need hop count to track accumulation</code></pre>
    <hr>

    <h2>The Solution: Two Distinguished Cells</h2>
    <h3>INPUT Cell (Edge Weight)</h3>
<pre><code>+-------------------------------------------------------------+
|  EDGE WEIGHTS                                               |
|                                                             |
|  Index:   0      1      2      k      4      5     ...     |
|          +------+------+------+------+------+------+       |
|  G1:     |  ?   |  ?   |  ?   | wk1  |  ?   |  ?   |       |
|          +------+------+------+------+------+------+       |
|          +------+------+------+------+------+------+       |
|  G2:     |  ?   |  ?   |  ?   | wk2  |  ?   |  ?   |       |
|          +------+------+------+------+------+------+       |
|                              &uarr;                              |
|                    Distinguished Edge k                     |
|                    We track: wk1, wk2                       |
|                    We know: |wk1 - wk2| &le; &epsilon;                 |
|                    INVARIANT: wk1, wk2 NEVER CHANGE         |
+-------------------------------------------------------------+</code></pre>

    <h3>OUTPUT Cell (Vertex Distance)</h3>
<pre><code>+-------------------------------------------------------------+
|  DISTANCES                                                  |
|                                                             |
|  Vertex:  0      1      2      v      4      5     ...     |
|          +------+------+------+------+------+------+       |
|  d1:     |  ?   |  ?   |  ?   | dv1  |  ?   |  ?   |       |
|          +------+------+------+------+------+------+       |
|          +------+------+------+------+------+------+       |
|  d2:     |  ?   |  ?   |  ?   | dv2  |  ?   |  ?   |       |
|          +------+------+------+------+------+------+       |
|                              &uarr;                              |
|                  Distinguished Vertex v                     |
|                  We track: dv1, dv2                         |
|                  BOUND: |dv1 - dv2| &le; max(h1,h2)&middot;&epsilon;       |
|                  CAN CHANGE during relaxation               |
+-------------------------------------------------------------+</code></pre>

    <h3>The Universal Quantification Trick</h3>
    <p>Both <code>k</code> and <code>v</code> are <strong>symbolic (universally quantified)</strong>:</p>
    <ul>
      <li>If we prove the property for arbitrary <code>k</code> and <code>v</code>, it holds for ALL edges and vertices!</li>
      <li>This reduces unbounded array reasoning to finite state.</li>
    </ul>
    <hr>

    <h2>The HIT/MISS Abstraction: Why Dijkstra Is Different</h2>

    <h3>Insertion Sort (Explicit HIT)</h3>
<pre><code>Reading A[k]:
  HIT (j = k):  key1' = ak1    &larr; We know EXACTLY what key1 becomes
  MISS (j &ne; k): key1' = ???    &larr; Unknown</code></pre>

    <h3>Kruskal (Explicit HIT)</h3>
<pre><code>Adding edge k to MST:
  HIT (e = k):  c1' = c1 + wk1  &larr; We know EXACTLY what c1 becomes
  MISS (e &ne; k): c1' = c1 + ???  &larr; Unknown weight</code></pre>

    <h3>Dijkstra (Abstracted HIT)</h3>
<pre><code>Relaxing vertex v via edge e:
  d[v] = d[u] + G[e]

  HIT (e = k):  dv1' = d[u] + wk1  &larr; We know wk1, but NOT d[u]!
  MISS (e &ne; k): dv1' = d[u] + ???  &larr; Unknown</code></pre>

    <div class="info-box purple">
      <strong>THE KEY DIFFERENCE</strong><br><br>
      In Dijkstra, even when we HIT the distinguished edge, we <strong>cannot compute the exact new distance</strong> because we don't track the predecessor distance <code>d[u]</code>.<br><br>
      <strong>Options considered:</strong>
      <ol style="margin:8px 0 8px 24px">
        <li><strong>Track predecessor distance</strong> &mdash; Adds complexity, may not help verification time</li>
        <li><strong>Decompose distance</strong> &mdash; Write <code>dv = rv + wk</code> where <code>rv</code> is "rest". Complex.</li>
        <li><strong>Abstract to hop count</strong> &mdash; Each edge contributes &le; &epsilon;. Simple and effective!</li>
      </ol>
      <br>
      We chose option 3. The encoding is simpler and verification succeeds.
    </div>

    <h3>The Hop Count Abstraction</h3>
<pre><code>Each edge on the path contributes &le; &epsilon; to |dv1 - dv2|
Path has h edges
Therefore: |dv1 - dv2| &le; h &middot; &epsilon;

This works for BOTH HIT and MISS:
  - HIT:  edge k contributes |wk1 - wk2| &le; &epsilon;
  - MISS: other edge contributes &le; &epsilon; (by input assumption)

Since both contribute the same bound, they are MERGED.</code></pre>
    <hr>

    <h2>State Variables</h2>
<pre><code>Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps)</code></pre>

    <h3>Control Flow Variables</h3>
    <table>
      <thead><tr><th>Variable</th><th>Type</th><th>Meaning</th><th>Changes?</th></tr></thead>
      <tbody>
        <tr><td><code>i1, i2</code></td><td>int</td><td>Iteration counter (for termination)</td><td>Yes</td></tr>
        <tr><td><code>h1, h2</code></td><td>int</td><td>Hop count (edges in shortest path to v)</td><td>Yes</td></tr>
        <tr><td><code>n</code></td><td>int</td><td>Number of vertices</td><td>Never</td></tr>
      </tbody>
    </table>

    <h3>Distinguished Cell Variables</h3>
    <table>
      <thead><tr><th>Variable</th><th>Type</th><th>Meaning</th><th>Changes?</th></tr></thead>
      <tbody>
        <tr><td><code>k</code></td><td>int</td><td>Distinguished edge index (symbolic)</td><td>Never</td></tr>
        <tr><td><code>wk1, wk2</code></td><td>real</td><td>Edge weights G1[k], G2[k]</td><td>Never</td></tr>
        <tr><td><code>bk</code></td><td>bool</td><td>Sign bit: <code>true</code> &rArr; wk2 &ge; wk1</td><td>Never</td></tr>
        <tr><td><code>dv1, dv2</code></td><td>real</td><td>Distances d1[v], d2[v]</td><td>Yes</td></tr>
        <tr><td><code>bv</code></td><td>bool</td><td>Sign bit: <code>true</code> &rArr; dv2 &ge; dv1</td><td>Yes</td></tr>
        <tr><td><code>eps</code></td><td>real</td><td>Perturbation bound (&epsilon; &ge; 0)</td><td>Never</td></tr>
      </tbody>
    </table>

    <h3>Why Two Runs?</h3>
    <p>We verify a <strong>relational property</strong> comparing two executions:</p>
    <ul>
      <li><strong>Run 1</strong>: Dijkstra on graph G1</li>
      <li><strong>Run 2</strong>: Dijkstra on graph G2</li>
    </ul>
    <p>The scheduler (SchTF, SchFT, SchTT) controls which run(s) take steps.</p>

    <h3>Note on wk1/wk2</h3>
    <p><code>k</code>, <code>wk1</code>, <code>wk2</code>, <code>bk</code> are kept for framework consistency with insertion sort and Kruskal, even though they are not used in transition cases. They document the input perturbation assumption. Future refinements could exploit them for an explicit HIT case if predecessor tracking is added.</p>
    <hr>

    <h2>The PCSAT Encoding</h2>

    <h3>Encoding Structure Overview</h3>
    <div class="info-box purple">
<pre style="border:none;margin:0;padding:0;background:transparent"><code>PCSAT CLAUSE STRUCTURE

1. INITIALIZATION
   Inv(...) :- initial_conditions.

2. TRANSITIONS (TF, FT, TT)
   Inv(updated) :-
       Inv(current),
       Scheduler(...),
       (no_change) or (relaxation) or (finished),
       epsilon_bound.

3. FAIRNESS CONSTRAINTS
   Ensure both runs can make progress

4. SCHEDULER DISJUNCTION
   At least one scheduler active when progress possible

5. GOAL CLAUSE
   Check if violation is reachable</code></pre>
    </div>

    <h3>Initialization</h3>
<pre><code>Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps) :-
    i1 = 0, i2 = 0,
    h1 = 0, h2 = 0,              (* No edges in path yet *)
    n &gt; 0, 0 &le; k, 0 &le; eps,
    (* INPUT: |wk1 - wk2| &le; eps *)
    (bk and 0 &le; wk2 - wk1 and wk2 - wk1 &le; eps) or
    (!bk and 0 &le; wk1 - wk2 and wk1 - wk2 &le; eps),
    (* OUTPUT: distances start equal *)
    dv1 = dv2.</code></pre>

    <h4>Explanation</h4>
    <p><strong>Initial state</strong>:</p>
    <ul>
      <li>Both runs at iteration 0, hop count 0</li>
      <li>Edge weights satisfy the input perturbation bound</li>
      <li>Distances start equal (both 0 for source, both &infin; for others)</li>
    </ul>
    <hr>

    <h3>TF Transition (Run 1 Steps)</h3>
    <p>Only <strong>Run 1</strong> takes a step while Run 2 waits.</p>
<pre><code>Inv(i1', i2, h1', h2, k, wk1, wk2, bk:bool, dv1', dv2, bv':bool, n, eps) :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    SchTF(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    (
        (* Case 1: No change to vertex v *)
        i1 &lt; n and i1' = i1 + 1 and
        h1' = h1 and dv1' = dv1
    ) or (
        (* Case 2: Relaxation - new shortest path to v *)
        (* HIT and MISS merged: both contribute &le; eps per edge *)
        i1 &lt; n and i1' = i1 + 1 and
        h1' &ge; 1 and h1' &lt; n
    ) or (
        (* Case 3: Finished - stutter *)
        i1 &ge; n and i1' = i1 and
        h1' = h1 and dv1' = dv1
    ),
    (* EPSILON BOUND: |dv1' - dv2| &le; max(h1', h2) * eps *)
    (h1' &ge; h2 and bv' and 0 &le; dv2 - dv1' and dv2 - dv1' &le; h1' * eps) or
    (h1' &ge; h2 and !bv' and 0 &le; dv1' - dv2 and dv1' - dv2 &le; h1' * eps) or
    (h2 &gt; h1' and bv' and 0 &le; dv2 - dv1' and dv2 - dv1' &le; h2 * eps) or
    (h2 &gt; h1' and !bv' and 0 &le; dv1' - dv2 and dv1' - dv2 &le; h2 * eps).</code></pre>

    <h4>Case 1: No Change</h4>
    <p><strong>Situation</strong>: Vertex v not affected this iteration.</p>
    <ul>
      <li><code>dv1' = dv1</code> (distance unchanged)</li>
      <li><code>h1' = h1</code> (hop count unchanged)</li>
    </ul>

    <h4>Case 2: Relaxation</h4>
    <p><strong>Situation</strong>: New shortest path to v found.</p>
    <ul>
      <li><code>h1' &isin; [1, n-1]</code>: new path has h1' edges</li>
      <li><code>dv1'</code> is unconstrained here; the epsilon bound clause limits it</li>
      <li>HIT and MISS are merged &mdash; both contribute &le; &epsilon; per edge</li>
    </ul>

    <h4>Case 3: Finished</h4>
    <p><strong>Situation</strong>: Algorithm complete, stutter step.</p>
    <ul>
      <li><code>i1 &ge; n</code>: all iterations done</li>
      <li><code>dv1' = dv1</code>, <code>h1' = h1</code>: nothing changes</li>
    </ul>

    <h4>The Epsilon Bound Clause</h4>
    <p>Every transition ends with the epsilon bound using <code>max(h1', h2)</code>:</p>
<pre><code>(h1' &ge; h2 and bv' and 0 &le; dv2 - dv1' and dv2 - dv1' &le; h1' * eps) or
(h1' &ge; h2 and !bv' and 0 &le; dv1' - dv2 and dv1' - dv2 &le; h1' * eps) or
(h2 &gt; h1' and bv' and 0 &le; dv2 - dv1' and dv2 - dv1' &le; h2 * eps) or
(h2 &gt; h1' and !bv' and 0 &le; dv1' - dv2 and dv1' - dv2 &le; h2 * eps).</code></pre>
    <p>This enforces: <code>|dv1' - dv2| &le; max(h1', h2) &middot; eps</code></p>
    <p><strong>Note</strong>: We use <code>dv2</code> (not <code>dv2'</code>) because in TF, only run 1 steps!</p>
    <hr>

    <h3>Why max(h1', h2)?</h3>
<pre><code>Run 1: path with h1 edges &rarr; accumulated error &le; h1&middot;&epsilon;
Run 2: path with h2 edges &rarr; accumulated error &le; h2&middot;&epsilon;

The longer path has more potential error.
So: |dv1 - dv2| &le; max(h1, h2) &middot; &epsilon;</code></pre>
    <hr>

    <h3>FT Transition (Run 2 Steps)</h3>
    <p>Symmetric to TF, but only Run 2 steps. The epsilon bound uses <code>h1</code> (unchanged) and <code>h2'</code> (updated).</p>
<pre><code>Inv(i1, i2', h1, h2', k, wk1, wk2, bk:bool, dv1, dv2', bv':bool, n, eps) :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    SchFT(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    (
        i2 &lt; n and i2' = i2 + 1 and h2' = h2 and dv2' = dv2
    ) or (
        i2 &lt; n and i2' = i2 + 1 and h2' &ge; 1 and h2' &lt; n
    ) or (
        i2 &ge; n and i2' = i2 and h2' = h2 and dv2' = dv2
    ),
    (* EPSILON BOUND: |dv1 - dv2'| &le; max(h1, h2') * eps *)
    (h1 &ge; h2' and bv' and 0 &le; dv2' - dv1 and dv2' - dv1 &le; h1 * eps) or
    (h1 &ge; h2' and !bv' and 0 &le; dv1 - dv2' and dv1 - dv2' &le; h1 * eps) or
    (h2' &gt; h1 and bv' and 0 &le; dv2' - dv1 and dv2' - dv1 &le; h2' * eps) or
    (h2' &gt; h1 and !bv' and 0 &le; dv1 - dv2' and dv1 - dv2' &le; h2' * eps).</code></pre>
    <hr>

    <h3>TT Transition (Both Step)</h3>
    <p>Both runs step simultaneously. Uses <strong>Cartesian product</strong>: independent blocks for run 1 and run 2.</p>
<pre><code>Inv(i1', i2', h1', h2', k, wk1, wk2, bk:bool, dv1', dv2', bv':bool, n, eps) :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    SchTT(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    (* Run 1: independent cases *)
    (i1 &lt; n and i1' = i1 + 1 and h1' = h1 and dv1' = dv1) or
    (i1 &lt; n and i1' = i1 + 1 and h1' &ge; 1 and h1' &lt; n) or
    (i1 &ge; n and i1' = i1 and h1' = h1 and dv1' = dv1),
    (* Run 2: independent cases *)
    (i2 &lt; n and i2' = i2 + 1 and h2' = h2 and dv2' = dv2) or
    (i2 &lt; n and i2' = i2 + 1 and h2' &ge; 1 and h2' &lt; n) or
    (i2 &ge; n and i2' = i2 and h2' = h2 and dv2' = dv2),
    (* EPSILON BOUND: |dv1' - dv2'| &le; max(h1', h2') * eps *)
    (h1' &ge; h2' and bv' and ... ) or ... .</code></pre>
    <p>Since HIT/MISS are merged, no HIT-HIT/HIT-MISS/MISS-HIT/MISS-MISS matrix is needed (unlike Kruskal). This is a key structural simplification.</p>
    <hr>

    <h3>Scheduler Clauses</h3>
    <h4>Fairness Constraints</h4>
<pre><code>(* If TF is chosen and run 2 can progress, run 1 must be able to progress *)
i1 &lt; n :-
    Inv(...),
    SchTF(...),
    i2 &lt; n.

(* Symmetric for FT *)
i2 &lt; n :-
    Inv(...),
    SchFT(...),
    i1 &lt; n.</code></pre>

    <h4>Scheduler Disjunction</h4>
<pre><code>(* At least one scheduler must be active when progress is possible *)
SchTF(...), SchFT(...), SchTT(...) :-
    Inv(...),
    i1 &lt; n or i2 &lt; n.</code></pre>
    <p><strong>Note</strong>: This is a <strong>non-Horn clause</strong> (multiple atoms in the head). This makes the problem pfwCSP rather than standard CHC.</p>
    <hr>

    <h3>Goal Clause</h3>
<pre><code>(* Check if violation is reachable at termination *)
dv1 - dv2 &gt; (n - 1) * eps or dv2 - dv1 &gt; (n - 1) * eps :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    n &le; i1, n &le; i2.</code></pre>
    <p><strong>Meaning</strong>: At termination (both algorithms finished), is <code>|dv1 - dv2| &gt; (n-1)*eps</code> possible?</p>
    <ul>
      <li><strong>UNSAT</strong>: No! Violation unreachable &rarr; <strong>(N-1)-robustness verified!</strong></li>
      <li><strong>SAT</strong>: Yes, violation is possible &rarr; Property does NOT hold</li>
    </ul>
    <hr>

    <h2>Verification Results</h2>
    <h3>Running the Verification</h3>
<pre><code>pcsat dijkstra_robustness.clp</code></pre>

    <h3>Test Results</h3>
    <table>
      <thead><tr><th>Goal Clause</th><th>Result</th><th>Time</th><th>Interpretation</th></tr></thead>
      <tbody>
        <tr><td><code>|dv1 - dv2| &le; (n-1)*eps</code></td><td><strong>SAT</strong></td><td>~1 min</td><td>Bound CAN be satisfied &check;</td></tr>
        <tr><td><code>|dv1 - dv2| &gt; (n-1)*eps</code></td><td><strong>UNSAT</strong></td><td>~5 min</td><td>Bound CANNOT be violated &check;</td></tr>
        <tr><td><code>|wk1 - wk2| &le; eps</code></td><td><strong>SAT</strong></td><td>&mdash;</td><td>Input bound maintained &check;</td></tr>
        <tr><td><code>dv1 = dv2</code></td><td><strong>UNSAT</strong></td><td>&mdash;</td><td>Exact equality too strong &check;</td></tr>
        <tr><td><code>|dv1 - dv2| &gt; eps</code> (1-robust)</td><td><strong>SAT</strong></td><td>&mdash;</td><td>1-robustness does NOT hold &check;</td></tr>
        <tr><td><code>|dv1 - dv2| &gt; n*eps</code> (N-robust)</td><td><strong>UNSAT</strong></td><td>&mdash;</td><td>Looser N*eps also holds &check;</td></tr>
      </tbody>
    </table>

    <h4>UNSAT for Violation</h4>
<pre><code>Goal: dv1 - dv2 &gt; (n - 1) * eps or dv2 - dv1 &gt; (n - 1) * eps
Result: UNSAT

Meaning: "There is NO reachable terminal state where |dv1 - dv2| &gt; (N-1)&middot;&epsilon;"
         &rarr; The bound can NEVER be violated!
         &rarr; This PROVES (N-1)-ROBUSTNESS! &check;</code></pre>

    <h4>SAT for 1-Robust Violation</h4>
<pre><code>Goal: dv1 - dv2 &gt; eps or dv2 - dv1 &gt; eps
Result: SAT

Meaning: "There EXISTS a reachable state where |dv1 - dv2| &gt; &epsilon;"
         &rarr; 1-robustness does NOT hold for Dijkstra
         &rarr; This confirms the bound must be (N-1)&middot;&epsilon;, not just &epsilon;</code></pre>

    <div class="info-box success">
      <strong>VERIFICATION COMPLETE</strong><br><br>
      <strong>Property:</strong> (N-1)-Robustness of Dijkstra's Algorithm<br>
      <strong>Statement:</strong> &forall;e. |G1[e] - G2[e]| &le; &epsilon; &rArr; &forall;v. |d1[v] - d2[v]| &le; (N-1)&middot;&epsilon;<br>
      <strong>Result:</strong> VERIFIED &check;<br>
      <strong>Evidence:</strong> Violation query returns UNSAT (no counterexample exists)
    </div>
    <hr>

    <h2>Comparison: Dijkstra vs Insertion Sort vs Kruskal</h2>
    <h3>Property Comparison</h3>
    <table>
      <thead><tr><th>Aspect</th><th>Insertion Sort</th><th>Kruskal MST</th><th>Dijkstra</th></tr></thead>
      <tbody>
        <tr><td><strong>Type</strong></td><td>1-robust</td><td>(N-1)-robust</td><td>(N-1)-robust</td></tr>
        <tr><td><strong>Values</strong></td><td>Preserved (move only)</td><td>Accumulate</td><td>Accumulate</td></tr>
        <tr><td><strong>INPUT cell</strong></td><td>Array element</td><td>Edge weight</td><td>Edge weight</td></tr>
        <tr><td><strong>OUTPUT cell</strong></td><td>Same as input</td><td>MST cost</td><td>Vertex distance</td></tr>
        <tr><td><strong>HIT case</strong></td><td><code>key1' = ak1</code> (explicit)</td><td><code>c1' = c1 + wk1</code> (explicit)</td><td>Abstracted to hop count</td></tr>
        <tr><td><strong>Key invariant</strong></td><td><code>|ak1-ak2| &le; &epsilon;</code></td><td><code>|c1-c2| &le; i&middot;&epsilon;</code></td><td><code>|dv1-dv2| &le; h&middot;&epsilon;</code></td></tr>
        <tr><td><strong>Final bound</strong></td><td>&epsilon;</td><td>(N-1)&middot;&epsilon;</td><td>(N-1)&middot;&epsilon;</td></tr>
        <tr><td><strong>wk1/wk2 in transitions?</strong></td><td>N/A</td><td>Yes (in cost)</td><td>No (abstracted)</td></tr>
      </tbody>
    </table>

    <h3>Structural Differences</h3>
<pre><code>Insertion Sort:
  - ONE distinguished cell (array element)
  - Values MOVE, never change arithmetically
  - ak1' = ak1 almost always

Kruskal:
  - TWO distinguished cells (edge weight + MST cost)
  - Cost ACCUMULATES: c1' = c1 + wk1 (HIT) or c1' = c1 + ??? (MISS)
  - Explicit HIT/MISS matrix (HIT-HIT, HIT-MISS, MISS-HIT, MISS-MISS)

Dijkstra:
  - TWO distinguished cells (edge weight + vertex distance)
  - Distance REPLACED by relaxation: d[v] = d[u] + w
  - HIT/MISS merged via hop count abstraction
  - No HIT/MISS matrix needed (simpler encoding!)</code></pre>
    <hr>

    <h2>Key Takeaways</h2>
    <ol>
      <li><strong>Two Distinguished Cells</strong>: INPUT (edge weight, constant) and OUTPUT (distance, mutable). This pattern applies whenever input perturbation causes output perturbation.</li>
      <li><strong>Hop Count Abstraction</strong>: Use <code>h &le; N-1</code> to bound accumulated error. Each edge contributes &le; &epsilon;, so total error &le; h&middot;&epsilon;.</li>
      <li><strong>HIT/MISS Merged</strong>: When both HIT and MISS contribute the same bound, they can be merged into one case. This simplifies the encoding.</li>
      <li><strong>Always Include Finished Case</strong>: <code>i &ge; n and i' = i and dv' = dv</code> ensures the algorithm can stutter at termination.</li>
      <li><strong>Use max(h1, h2)</strong>: The longer path determines the worst-case accumulated error between two runs.</li>
      <li><strong>PCSAT Encoding Structure</strong>:
<pre><code>Inv(updated) :-
    Inv(current),
    Scheduler(...),
    (no_change) or (relaxation) or (finished),
    epsilon_bound.    &larr; SEPARATE clause at end!</code></pre>
      </li>
      <li><strong>Verification Interpretation</strong>:
        <table>
          <thead><tr><th>Goal</th><th>Result</th><th>Meaning</th></tr></thead>
          <tbody>
            <tr><td>Property holds</td><td>SAT</td><td>Property is achievable &check;</td></tr>
            <tr><td>Violation</td><td>UNSAT</td><td>Property is verified &check;</td></tr>
            <tr><td>Tighter bound (1-robust)</td><td>SAT</td><td>Too tight (expected for accumulating alg.)</td></tr>
          </tbody>
        </table>
      </li>
    </ol>
    <hr>

    <h2>References</h2>
    <ol>
      <li><strong>Chaudhuri, Gulwani, Lublinerman</strong> &mdash; "Continuity and Robustness of Programs" (CACM 2012)</li>
      <li><strong>Monniaux &amp; Gonnord</strong> &mdash; "Cell Morphing: From Array Programs to Array-Free Horn Clauses" (SAS 2016)</li>
      <li><strong>Unno, Terauchi, Kobayashi</strong> &mdash; "Constraint-based Relational Verification" (CAV 2021)</li>
      <li><strong>PCSAT Solver</strong> &mdash; Tool for solving predicate constraint satisfaction problems</li>
    </ol>
  </div>

  <!-- ============ SOURCE CODE PANEL ============ -->
  <div id="panel-source" class="panel">
    <div class="source-container">
      <div class="source-header">
        <span class="source-filename">dijkstra_robustness.clp</span>
        <button class="copy-btn" onclick="copySource()">Copy to clipboard</button>
      </div>
      <div class="source-lines">
        <div class="line-numbers" id="line-nums"></div>
        <div class="source-code" id="source-code"></div>
      </div>
    </div>
  </div>
</main>

<script>
// Tab switching
function switchTab(el) {
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('panel-' + el.dataset.panel).classList.add('active');
}

// Source code content
const sourceCode = `
(*
Dijkstra(G, src)
    for each v in G: d[v] := inf
    d[src] := 0
    WL := all nodes
    while WL <> empty:
        u := argmin d[v] for v in WL
        remove u from WL
        for each neighbor v of u:
            if d[u] + G[u,v] < d[v]:
                d[v] := d[u] + G[u,v]
    return d
*)

(*
PROPERTY: (N-1)-robust under L-infinity
  forall e. |G1[e] - G2[e]| <= eps  ==>  forall v. |d1[v] - d2[v]| <= (N-1)*eps

WHY (N-1)?
  Shortest path to any vertex uses at most N-1 edges.
  Each edge weight differs by at most eps between the two graphs.
  So the total distance difference is at most (N-1)*eps.

================================================================================
RELATIONAL CELL MORPHING
================================================================================

TWO DISTINGUISHED CELLS:

1. INPUT CELL (edge weight):
   - k: distinguished edge index (symbolic, universally quantified)
   - wk1, wk2: weights G1[k], G2[k]
   - bk: sign bit for |wk1 - wk2|
   - PRECONDITION: |wk1 - wk2| <= eps
   - wk1, wk2 NEVER CHANGE (input constants)

2. OUTPUT CELL (vertex distance):
   - v: distinguished vertex (implicit, universally quantified)
   - dv1, dv2: shortest distances d1[v], d2[v]
   - bv: sign bit for |dv1 - dv2|
   - POSTCONDITION: |dv1 - dv2| <= (N-1)*eps
   - dv1, dv2 CAN CHANGE during relaxation

================================================================================
HOP COUNT ABSTRACTION
================================================================================

Unlike Kruskal where cost accumulates additively (c' = c + w), in Dijkstra
distance is REPLACED by relaxation (d[v] = d[u] + w). We cannot make HIT
explicit because we do not track predecessor distance d[u].

Instead, we abstract via HOP COUNT:
  - h1, h2: number of edges in current shortest path to v
  - Each edge contributes at most eps to |dv1 - dv2|
  - INVARIANT: |dv1 - dv2| <= max(h1, h2) * eps
  - h <= N-1 always, so at termination: |dv1 - dv2| <= (N-1)*eps

Both HIT and MISS contribute at most eps per edge, so they are MERGED
into a single relaxation case. This is the key structural difference
from Kruskal.

================================================================================
STATE VARIABLES
================================================================================

  i1, i2      : iteration counters (for termination)
  h1, h2      : hop count = edges in current shortest path to v
  k           : distinguished edge index (NEVER CHANGES)
  wk1, wk2    : edge weights G1[k], G2[k] (NEVER CHANGE)
  bk          : sign bit for |wk1 - wk2| (NEVER CHANGES)
  dv1, dv2    : shortest distances to v (CAN CHANGE)
  bv          : sign bit for |dv1 - dv2|
  n           : number of vertices
  eps         : perturbation bound

NOTE: k, wk1, wk2, bk are kept for framework consistency with insertion sort
and Kruskal, even though they are not used in transition cases. They document
the input perturbation assumption. Future refinements could exploit them for
an explicit HIT case if predecessor tracking is added.
*)


(******************************************************************************)
(* INITIALIZATION                                                             *)
(******************************************************************************)

Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps) :-
    i1 = 0, i2 = 0,
    h1 = 0, h2 = 0,
    n > 0,
    0 <= k,
    0 <= eps,
    (* INPUT: |wk1 - wk2| <= eps *)
    (bk and 0 <= wk2 - wk1 and wk2 - wk1 <= eps) or
    (!bk and 0 <= wk1 - wk2 and wk1 - wk2 <= eps),
    (* OUTPUT: distances start equal *)
    (* Both runs begin with same distance (0 for source, inf for others) *)
    dv1 = dv2.


(******************************************************************************)
(* TF TRANSITION - Only run 1 steps                                           *)
(*                                                                            *)
(* Cases:                                                                     *)
(*   1. No change: vertex v not relaxed this iteration                        *)
(*   2. Relaxation: new shorter path found to v (HIT/MISS merged)             *)
(*      - h1' in [1, n-1]: new path has h1' edges                            *)
(*      - dv1' constrained only by epsilon bound                              *)
(*   3. Finished: i1 >= n, stutter                                            *)
(******************************************************************************)

Inv(i1', i2, h1', h2, k, wk1, wk2, bk:bool, dv1', dv2, bv':bool, n, eps) :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    SchTF(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    (
        (* Case 1: No change to vertex v *)
        i1 < n and i1' = i1 + 1 and
        h1' = h1 and dv1' = dv1
    ) or (
        (* Case 2: Relaxation - new shortest path to v *)
        (* HIT and MISS merged: both contribute <= eps per edge *)
        (* h1' = hop count of new path, can be any value in [1, n-1] *)
        (* dv1' is unconstrained here; epsilon bound below limits it *)
        i1 < n and i1' = i1 + 1 and
        h1' >= 1 and h1' < n
    ) or (
        (* Case 3: Finished - stutter *)
        i1 >= n and i1' = i1 and
        h1' = h1 and dv1' = dv1
    ),
    (* EPSILON BOUND: |dv1' - dv2| <= max(h1', h2) * eps *)
    (h1' >= h2 and bv' and 0 <= dv2 - dv1' and dv2 - dv1' <= h1' * eps) or
    (h1' >= h2 and !bv' and 0 <= dv1' - dv2 and dv1' - dv2 <= h1' * eps) or
    (h2 > h1' and bv' and 0 <= dv2 - dv1' and dv2 - dv1' <= h2 * eps) or
    (h2 > h1' and !bv' and 0 <= dv1' - dv2 and dv1' - dv2 <= h2 * eps).


(******************************************************************************)
(* FT TRANSITION - Only run 2 steps                                           *)
(*                                                                            *)
(* Symmetric to TF. Epsilon bound uses h1 (unchanged) and h2' (updated).      *)
(******************************************************************************)

Inv(i1, i2', h1, h2', k, wk1, wk2, bk:bool, dv1, dv2', bv':bool, n, eps) :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    SchFT(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    (
        (* Case 1: No change to vertex v *)
        i2 < n and i2' = i2 + 1 and
        h2' = h2 and dv2' = dv2
    ) or (
        (* Case 2: Relaxation *)
        i2 < n and i2' = i2 + 1 and
        h2' >= 1 and h2' < n
    ) or (
        (* Case 3: Finished - stutter *)
        i2 >= n and i2' = i2 and
        h2' = h2 and dv2' = dv2
    ),
    (* EPSILON BOUND: |dv1 - dv2'| <= max(h1, h2') * eps *)
    (h1 >= h2' and bv' and 0 <= dv2' - dv1 and dv2' - dv1 <= h1 * eps) or
    (h1 >= h2' and !bv' and 0 <= dv1 - dv2' and dv1 - dv2' <= h1 * eps) or
    (h2' > h1 and bv' and 0 <= dv2' - dv1 and dv2' - dv1 <= h2' * eps) or
    (h2' > h1 and !bv' and 0 <= dv1 - dv2' and dv1 - dv2' <= h2' * eps).


(******************************************************************************)
(* TT TRANSITION - Both runs step                                             *)
(*                                                                            *)
(* Uses Cartesian product: independent blocks for run 1 and run 2.            *)
(* This automatically handles all combinations:                               *)
(*   - Both working (no change / relax x no change / relax)                   *)
(*   - One finished, other working                                            *)
(*   - Both finished                                                          *)
(*                                                                            *)
(* Since HIT/MISS are merged, no HIT-HIT/HIT-MISS/MISS-HIT/MISS-MISS         *)
(* matrix is needed (unlike Kruskal).                                         *)
(******************************************************************************)

Inv(i1', i2', h1', h2', k, wk1, wk2, bk:bool, dv1', dv2', bv':bool, n, eps) :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    SchTT(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    (* Run 1: independent cases *)
    (
        (* No change *)
        i1 < n and i1' = i1 + 1 and h1' = h1 and dv1' = dv1
    ) or (
        (* Relaxation *)
        i1 < n and i1' = i1 + 1 and h1' >= 1 and h1' < n
    ) or (
        (* Finished *)
        i1 >= n and i1' = i1 and h1' = h1 and dv1' = dv1
    ),
    (* Run 2: independent cases *)
    (
        (* No change *)
        i2 < n and i2' = i2 + 1 and h2' = h2 and dv2' = dv2
    ) or (
        (* Relaxation *)
        i2 < n and i2' = i2 + 1 and h2' >= 1 and h2' < n
    ) or (
        (* Finished *)
        i2 >= n and i2' = i2 and h2' = h2 and dv2' = dv2
    ),
    (* EPSILON BOUND: |dv1' - dv2'| <= max(h1', h2') * eps *)
    (h1' >= h2' and bv' and 0 <= dv2' - dv1' and dv2' - dv1' <= h1' * eps) or
    (h1' >= h2' and !bv' and 0 <= dv1' - dv2' and dv1' - dv2' <= h1' * eps) or
    (h2' > h1' and bv' and 0 <= dv2' - dv1' and dv2' - dv1' <= h2' * eps) or
    (h2' > h1' and !bv' and 0 <= dv1' - dv2' and dv1' - dv2' <= h2' * eps).


(******************************************************************************)
(* SCHEDULER FAIRNESS                                                         *)
(******************************************************************************)

(* If TF chosen and run 2 can progress, run 1 must be able to *)
i1 < n :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    SchTF(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    i2 < n.

(* If FT chosen and run 1 can progress, run 2 must be able to *)
i2 < n :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    SchFT(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    i1 < n.

(* Scheduler disjunction: at least one run can progress *)
SchTF(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
SchFT(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
SchTT(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps) :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    i1 < n or i2 < n.


(******************************************************************************)
(* GOAL: (N-1)-ROBUSTNESS                                                     *)
(*                                                                            *)
(* Violation goal: is |dv1 - dv2| > (N-1)*eps reachable at termination?       *)
(* UNSAT = violation unreachable = (N-1)-robustness VERIFIED                   *)
(******************************************************************************)

dv1 - dv2 > (n - 1) * eps or dv2 - dv1 > (n - 1) * eps :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    n <= i1, n <= i2.


(******************************************************************************)
(* TEST QUERIES (uncomment one at a time to run)                              *)
(******************************************************************************)

(*
(* Test 1: (N-1)*eps bound maintained at termination - expected SAT *)
(* SAT means the bound CAN be achieved, confirming it is not vacuous *)
dv1 - dv2 <= (n - 1) * eps and dv2 - dv1 <= (n - 1) * eps :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    n <= i1, n <= i2.

(* Test 2: Violation unreachable - expected UNSAT *)
(* UNSAT = (N-1)-robustness VERIFIED *)
dv1 - dv2 > (n - 1) * eps or dv2 - dv1 > (n - 1) * eps :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    n <= i1, n <= i2.

(* Test 3: Input edge weight bound - expected SAT *)
wk1 - wk2 <= eps and wk2 - wk1 <= eps :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps).

(* Test 4: Exact equality at termination - expected UNSAT *)
(* Too strong: distances can differ by up to (N-1)*eps *)
dv1 = dv2 :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    n <= i1, n <= i2.

(* Test 5: 1-robust (too tight) - expected SAT *)
(* SAT = violation IS reachable = 1-robustness does NOT hold *)
dv1 - dv2 > eps or dv2 - dv1 > eps :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    n <= i1, n <= i2.

(* Test 6: N*eps bound (looser) - expected UNSAT *)
(* UNSAT confirms N*eps also holds (weaker than (N-1)*eps) *)
dv1 - dv2 > n * eps or dv2 - dv1 > n * eps :-
    Inv(i1, i2, h1, h2, k, wk1, wk2, bk:bool, dv1, dv2, bv:bool, n, eps),
    n <= i1, n <= i2.
*)`.trim();

// Render source with line numbers and syntax highlighting
function renderSource() {
  const lines = sourceCode.split('\n');
  const numEl = document.getElementById('line-nums');
  const codeEl = document.getElementById('source-code');

  let numsHtml = '';
  let codeHtml = '';

  lines.forEach((line, i) => {
    numsHtml += '<span>' + (i + 1) + '</span>';
    codeHtml += highlightLine(escapeHtml(line)) + '\n';
  });

  numEl.innerHTML = numsHtml;
  codeEl.innerHTML = codeHtml;
}

function escapeHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function highlightLine(line) {
  // Comments
  line = line.replace(/(\(\*.*?\*\))/g, '<span class="comment">$1</span>');
  line = line.replace(/(\/\/.*$)/g, '<span class="comment">$1</span>');

  // Predicates
  line = line.replace(/\b(Inv|SchTF|SchFT|SchTT)\b/g, '<span class="predicate">$1</span>');

  // Keywords
  line = line.replace(/\b(and|or|not)\b/g, '<span class="keyword">$1</span>');
  line = line.replace(/(:-)/g, '<span class="keyword">$1</span>');

  // Booleans and types
  line = line.replace(/\b(bool|true|false)\b/g, '<span class="bool">$1</span>');

  // Operators
  line = line.replace(/(&lt;=|&gt;=|&lt;&gt;|&lt;|&gt;)/g, '<span class="operator">$1</span>');

  return line;
}

function copySource() {
  navigator.clipboard.writeText(sourceCode).then(() => {
    const btn = document.querySelector('.copy-btn');
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy to clipboard', 2000);
  });
}

// Initialize
renderSource();
</script>

</body>
</html>
