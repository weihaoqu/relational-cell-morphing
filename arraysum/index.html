<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ArraySum Monotonicity Verification</title>
<style>
  :root {
    --bg: #ffffff;
    --surface: #f6f8fa;
    --surface2: #eef1f5;
    --border: #d1d9e0;
    --text: #1f2328;
    --text-dim: #656d76;
    --accent: #0969da;
    --accent2: #1a7f37;
    --accent3: #8250df;
    --code-bg: #f6f8fa;
    --tab-hover: #eef1f5;
    --highlight: #0969da1a;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
  }
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 24px 0 0;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .header-content {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 24px;
  }
  .header-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 4px;
  }
  .header-sub {
    color: var(--text-dim);
    font-size: 0.875rem;
    margin-bottom: 16px;
  }
  .tabs {
    display: flex;
    gap: 0;
  }
  .tab {
    padding: 10px 20px;
    cursor: pointer;
    color: var(--text-dim);
    font-size: 0.875rem;
    font-weight: 500;
    border-bottom: 2px solid transparent;
    transition: color 0.15s, border-color 0.15s, background 0.15s;
    user-select: none;
    border-radius: 6px 6px 0 0;
  }
  .tab:hover {
    color: var(--text);
    background: var(--tab-hover);
  }
  .tab.active {
    color: var(--text);
    border-bottom-color: var(--accent);
  }
  .tab .tab-icon { margin-right: 6px; }

  main {
    max-width: 1100px;
    margin: 0 auto;
    padding: 32px 24px 80px;
  }
  .panel { display: none; }
  .panel.active { display: block; }

  /* Markdown-rendered content */
  .content h1 { font-size: 1.75rem; margin: 32px 0 16px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
  .content h1:first-child { margin-top: 0; }
  .content h2 { font-size: 1.375rem; margin: 28px 0 12px; padding-bottom: 6px; border-bottom: 1px solid var(--border); color: var(--accent); }
  .content h3 { font-size: 1.1rem; margin: 20px 0 8px; color: var(--accent3); }
  .content h4 { font-size: 1rem; margin: 16px 0 8px; color: var(--text-dim); }
  .content p { margin: 12px 0; }
  .content strong { color: #1f2328; }
  .content blockquote {
    border-left: 3px solid var(--accent);
    padding: 8px 16px;
    margin: 12px 0;
    background: var(--surface);
    border-radius: 0 6px 6px 0;
    color: var(--text-dim);
  }
  .content ul, .content ol { margin: 8px 0 8px 24px; }
  .content li { margin: 4px 0; }
  .content hr { border: none; border-top: 1px solid var(--border); margin: 24px 0; }
  .content a { color: var(--accent); text-decoration: none; }
  .content a:hover { text-decoration: underline; }
  .content table {
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
    font-size: 0.875rem;
  }
  .content table th {
    text-align: left;
    padding: 10px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    font-weight: 600;
    color: var(--accent);
  }
  .content table td {
    padding: 8px 14px;
    border: 1px solid var(--border);
  }
  .content table tr:hover td {
    background: var(--surface);
  }
  .content code {
    font-family: 'SF Mono', 'Fira Code', 'Fira Mono', Menlo, Consolas, monospace;
    background: var(--surface2);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.85em;
    color: var(--accent3);
  }
  .content pre {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px 20px;
    overflow-x: auto;
    margin: 16px 0;
    position: relative;
  }
  .content pre code {
    background: none;
    padding: 0;
    border-radius: 0;
    font-size: 0.8125rem;
    color: var(--text);
    line-height: 1.5;
  }

  /* Source code panel */
  .source-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  .source-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: var(--surface2);
    border-bottom: 1px solid var(--border);
    font-size: 0.8125rem;
    color: var(--text-dim);
  }
  .source-filename {
    font-family: 'SF Mono', Menlo, Consolas, monospace;
    color: var(--text);
    font-weight: 500;
  }
  .source-lines {
    display: flex;
    overflow-x: auto;
    font-family: 'SF Mono', 'Fira Code', Menlo, Consolas, monospace;
    font-size: 0.8125rem;
    line-height: 1.6;
  }
  .line-numbers {
    padding: 16px 0;
    text-align: right;
    color: var(--text-dim);
    user-select: none;
    min-width: 48px;
    opacity: 0.5;
    border-right: 1px solid var(--border);
  }
  .line-numbers span {
    display: block;
    padding: 0 12px;
  }
  .source-code {
    padding: 16px;
    flex: 1;
    white-space: pre;
    color: var(--text);
  }
  .source-code .comment { color: #6a737d; font-style: italic; }
  .source-code .keyword { color: #cf222e; }
  .source-code .predicate { color: #0550ae; }
  .source-code .operator { color: #8250df; }
  .source-code .bool { color: #1a7f37; }
  .source-code .number { color: #953800; }

  /* Copy button */
  .copy-btn {
    background: var(--surface);
    color: var(--text-dim);
    border: 1px solid var(--border);
    padding: 4px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.15s;
  }
  .copy-btn:hover { color: var(--text); background: var(--tab-hover); }

  /* Info boxes */
  .info-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent);
    border-radius: 0 6px 6px 0;
    padding: 16px 20px;
    margin: 20px 0;
  }
  .info-box.success { border-left-color: var(--accent2); }
  .info-box.purple { border-left-color: var(--accent3); }

  /* Top navigation */
  .topnav { border-bottom: 1px solid var(--border); font-size: 0.8rem; }
  .topnav-content {
    max-width: 1100px; margin: 0 auto; padding: 0 24px;
    display: flex; align-items: center; gap: 2px; flex-wrap: wrap;
  }
  .topnav-home {
    color: var(--accent); text-decoration: none; font-weight: 500;
    padding: 8px 0; white-space: nowrap; margin-right: 8px;
  }
  .topnav-home:hover { text-decoration: underline; }
  .nav-group { position: relative; }
  .nav-group-btn {
    background: none; border: none; cursor: pointer;
    color: var(--text-dim); font-size: 0.8rem; padding: 8px 12px;
    border-radius: 4px; font-family: inherit;
    transition: color 0.15s, background 0.15s;
  }
  .nav-group-btn:hover, .nav-group:focus-within .nav-group-btn {
    color: var(--text); background: var(--surface2);
  }
  .nav-group-btn.active { color: var(--text); font-weight: 600; }
  .nav-dropdown {
    display: none; position: absolute; top: 100%; left: 0;
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 6px; padding: 4px 0; min-width: 160px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 200;
  }
  .nav-group:hover .nav-dropdown,
  .nav-group:focus-within .nav-dropdown { display: block; }
  .nav-dropdown a {
    display: block; padding: 6px 16px; color: var(--text-dim);
    text-decoration: none; white-space: nowrap;
    transition: background 0.1s, color 0.1s;
  }
  .nav-dropdown a:hover { background: var(--surface); color: var(--text); }
  .nav-dropdown a.active { color: var(--accent); font-weight: 600; background: var(--highlight); }

  /* Responsive */
  @media (max-width: 768px) {
    .tab { padding: 8px 12px; font-size: 0.8rem; }
    main { padding: 20px 16px 60px; }
    .header-title { font-size: 1.25rem; }
  }
</style>
</head>
<body>

<header>
  <div class="topnav">
    <div class="topnav-content">
      <a href="../" class="topnav-home">&larr; All Examples</a>
      <div class="nav-group">
        <button class="nav-group-btn">Robustness &#9662;</button>
        <div class="nav-dropdown">
          <a href="../isort/">Insertion Sort</a>
          <a href="../kruskal/">Kruskal</a>
          <a href="../dijk/">Dijkstra</a>
          <a href="../arraymax-robust/">ArrayMax</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Sensitivity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../histogram/">Histogram</a>
          <a href="../cdf/">CDF</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn active">Monotonicity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../arraymax/">ArrayMax</a>
          <a href="../arraysum/" class="active">ArraySum</a>
          <a href="../kruskal-mono/">Kruskal</a>
          <a href="../arraysum-qmono/">ArraySum (Quant.)</a>
          <a href="../dijk-mono/">Dijkstra (vacuous)</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Commutativity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../commutativity/">ArraySum</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Cost &#9662;</button>
        <div class="nav-dropdown">
          <a href="../countpositive/">CountPositive</a>
          <a href="../cost-ext/">Extensions</a>
        </div>
      </div>
    </div>
  </div>
  <div class="header-content">
    <div class="header-title">ArraySum Monotonicity Verification</div>
    <div class="header-sub">Relational Cell Morphing with PCSAT &mdash; Monotonicity Proof</div>
    <div class="tabs">
      <div class="tab active" data-panel="simple" onclick="switchTab(this)">
        <span class="tab-icon">&#128196;</span>Overview
      </div>
      <div class="tab" data-panel="detailed" onclick="switchTab(this)">
        <span class="tab-icon">&#128214;</span>Detailed Tutorial
      </div>
      <div class="tab" data-panel="source" onclick="switchTab(this)">
        <span class="tab-icon">&#128187;</span>Source Code
      </div>
    </div>
  </div>
</header>

<main>
  <!-- ============ SIMPLE / OVERVIEW PANEL ============ -->
  <div id="panel-simple" class="panel active content">
    <h1>ArraySum Monotonicity Verification with PCSAT</h1>
    <p>A concise tutorial on verifying monotonicity of array summation using relational cell morphing.</p>
    <hr>

    <h2>The Algorithm</h2>
<pre><code>ArraySum(A: array, n: size)
    s := 0
    for i = 0 to n-1:
        s := s + A[i]
    return s</code></pre>
    <p><strong>Key observation</strong>: The algorithm scans left to right with a fixed iteration order, independent of data values. The running sum is <strong>non-decreasing</strong> when array values are non-negative.</p>
    <hr>

    <h2>The Property: Monotonicity</h2>
<pre><code>&forall;i. A1[i] &le; A2[i]  &rArr;  ArraySum(A1) &le; ArraySum(A2)
     ~~~~~~~~~~~~~~~~     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     INPUT: every element     OUTPUT: sum of A1
     of A1 &le; corr. in A2     &le; sum of A2</code></pre>
    <p><strong>In plain English</strong>: If every element of array A1 is at most the corresponding element of A2, then the sum of A1 is at most the sum of A2.</p>
    <p><strong>Assumption</strong>: All array values are non-negative (<code>A[i] &ge; 0</code> for all <code>i</code>). This ensures the running sum is non-decreasing, giving the solver enough information in the MISS case.</p>

    <h3>Example</h3>
<pre><code>A1 = [3, 1, 7, 2, 5]    &rarr;  sum(A1) = 18
A2 = [4, 3, 9, 2, 8]    &rarr;  sum(A2) = 26

Pointwise: 3&le;4, 1&le;3, 7&le;9, 2&le;2, 5&le;8  &check;
Result:    18 &le; 26  &check;</code></pre>
    <hr>

    <h2>The Solution: Relational Cell Morphing</h2>
    <h3>The Problem</h3>
    <p>We need to verify a property about <strong>all array indices</strong>, but CHC solvers can't handle quantified array properties directly.</p>

    <h3>The Solution: Two Distinguished Cells</h3>
    <p>Instead of tracking the entire array, we track <strong>one symbolic input cell</strong> and the <strong>output accumulator</strong>:</p>
<pre><code>&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdr;
&boxv;  INPUT CELL (Array Element)                                 &boxv;
&boxv;                                                             &boxv;
&boxv;  k:    Distinguished index (SYMBOLIC)                       &boxv;
&boxv;  wk1:  A1[k] &mdash; value in array 1                            &boxv;
&boxv;  wk2:  A2[k] &mdash; value in array 2                            &boxv;
&boxv;  PRECONDITION: 0 &le; wk1 &le; wk2                               &boxv;
&boxv;  k, wk1, wk2 NEVER CHANGE                                  &boxv;
&boxv;                                                             &boxv;
&boxv;  OUTPUT CELL (Running Sum)                                  &boxv;
&boxv;                                                             &boxv;
&boxv;  s1:   Current sum in run 1                                 &boxv;
&boxv;  s2:   Current sum in run 2                                 &boxv;
&boxv;  POSTCONDITION: s1 &le; s2 (monotonicity)                     &boxv;
&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdr;</code></pre>
    <p><strong>Key insight</strong>: <code>k</code> is <strong>symbolic</strong> (universally quantified). If we prove the property for arbitrary <code>k</code>, it holds for ALL indices!</p>
    <hr>

    <h2>State Variables</h2>
<pre><code>Inv(i1, i2, k, wk1, wk2, s1, s2, n)</code></pre>
    <table>
      <thead>
        <tr><th>Variable</th><th>Type</th><th>Meaning</th><th>Changes?</th></tr>
      </thead>
      <tbody>
        <tr><td><code>i1, i2</code></td><td>int</td><td>Current index in runs 1 and 2</td><td>Yes (0 &rarr; n)</td></tr>
        <tr><td><code>k</code></td><td>int</td><td>Distinguished element index (symbolic)</td><td>Never</td></tr>
        <tr><td><code>wk1</code></td><td>real</td><td>A1[k] &mdash; value in array 1</td><td>Never</td></tr>
        <tr><td><code>wk2</code></td><td>real</td><td>A2[k] &mdash; value in array 2</td><td>Never</td></tr>
        <tr><td><code>s1, s2</code></td><td>real</td><td>Running sums in runs 1 and 2</td><td>Yes (non-decreasing)</td></tr>
        <tr><td><code>n</code></td><td>int</td><td>Array size</td><td>Never</td></tr>
      </tbody>
    </table>
    <p><strong>Only 8 variables</strong> &mdash; same as ArrayMax monotonicity. No sign bits, no epsilon, no hop counts. Direction is known (<code>wk1 &le; wk2</code>), so no sign-bit encoding is needed.</p>
    <hr>

    <h2>The HIT/MISS Abstraction</h2>
    <p>When processing element <code>i</code>:</p>
    <table>
      <thead>
        <tr><th>Case</th><th>Condition</th><th>What We Know</th></tr>
      </thead>
      <tbody>
        <tr><td><strong>HIT</strong></td><td><code>i = k</code></td><td>Processing distinguished element &rarr; <code>s1' = s1 + wk1</code> (exact!)</td></tr>
        <tr><td><strong>MISS</strong></td><td><code>i &ne; k</code></td><td>Processing other element &rarr; value unknown but &ge; 0, so <code>s1' &ge; s1</code></td></tr>
      </tbody>
    </table>

    <h3>Why HIT Preserves Monotonicity</h3>
<pre><code>HIT (i = k):
  s1' = s1 + wk1
  s2' = s2 + wk2

  Given: s1 &le; s2  and  wk1 &le; wk2
  Then:  s1 + wk1 &le; s2 + wk2
  So:    s1' &le; s2'  &check;

  NO sub-cases needed! (Unlike ArrayMax's 4 sub-cases)
  Addition is monotone in both arguments directly.

MISS (i &ne; k):
  s1' = s1 + A1[i]     &larr; A1[i] UNKNOWN but &ge; 0
  s2' = s2 + A2[i]     &larr; A2[i] UNKNOWN but &ge; 0

  Only know: s1' &ge; s1, s2' &ge; s2
  Solver must discover the invariant on its own.</code></pre>
    <hr>

    <h2>Comparison with ArrayMax</h2>
    <p>Both are monotonicity proofs using the same async cell morphing framework:</p>
    <table>
      <thead>
        <tr><th>Aspect</th><th>ArraySum</th><th>ArrayMax</th></tr>
      </thead>
      <tbody>
        <tr><td>Update</td><td><code>s = s + A[i]</code> &mdash; linear</td><td><code>m = max(m, A[i])</code> &mdash; branching</td></tr>
        <tr><td>HIT encoding</td><td>1 expression</td><td>4 sub-cases (2&times;2)</td></tr>
        <tr><td>MISS encoding</td><td><code>s1' &ge; s1</code></td><td><code>m1' &ge; m1</code></td></tr>
        <tr><td>UNSAT time</td><td><strong>47 seconds</strong></td><td>8m 35s</td></tr>
        <tr><td>Variables</td><td>8</td><td>8</td></tr>
      </tbody>
    </table>
    <p><strong>Why 10x faster?</strong> ArraySum's HIT is a single linear constraint (<code>s1' = s1 + wk1</code>) with no internal branching. ArrayMax's HIT involves a max operation that requires 2 branches per run, creating 4 sub-cases in TT. <strong>Fewer disjuncts = faster solver.</strong></p>
    <hr>

    <h2>Verification Results</h2>
    <table>
      <thead>
        <tr><th>Goal</th><th>Result</th><th>Time</th><th>Meaning</th></tr>
      </thead>
      <tbody>
        <tr><td><code>s1 &gt; s2</code> at termination</td><td><strong>UNSAT</strong></td><td>47.2s</td><td><strong>Monotonicity VERIFIED</strong> &check;</td></tr>
        <tr><td><code>s1 &ge; 0</code> at termination</td><td><strong>SAT</strong></td><td>17s</td><td>Non-vacuity confirmed &check;</td></tr>
        <tr><td><code>n &gt; 0</code> at termination</td><td><strong>SAT</strong></td><td>12s</td><td>Non-vacuity confirmed &check;</td></tr>
        <tr><td><code>s1 &gt; s2</code> mid-execution</td><td>SAT</td><td>12.5s</td><td>Vacuous SAT (TT-only schedule)</td></tr>
        <tr><td><code>s1 &le; s2</code> at termination</td><td>timeout</td><td>&gt;10 hrs</td><td>PCSAT SAT/UNSAT asymmetry</td></tr>
      </tbody>
    </table>

    <div class="info-box success">
      <strong>VERIFICATION COMPLETE</strong><br><br>
      <strong>Property:</strong> Monotonicity of ArraySum<br>
      <strong>Statement:</strong> &forall;i. A1[i] &le; A2[i] &rArr; sum(A1) &le; sum(A2)<br>
      <strong>Result:</strong> VERIFIED &check;<br>
      <strong>Evidence:</strong> Violation query (<code>s1 &gt; s2</code>) returns UNSAT in 47s (88 iterations). Non-vacuity confirmed via <code>s1 &ge; 0</code> SAT (17s) and <code>n &gt; 0</code> SAT (12s).
    </div>
    <hr>

    <h2>Key Takeaways</h2>
    <ol>
      <li><strong>Relational Cell Morphing</strong>: Track one symbolic input cell <code>k</code> and the running sum, instead of the entire array. Since <code>k</code> is universally quantified, the proof holds for all indices.</li>
      <li><strong>HIT/MISS Abstraction</strong>: HIT (<code>i = k</code>) &rarr; use exact value <code>s1' = s1 + wk1</code>; MISS (<code>i &ne; k</code>) &rarr; non-deterministic but non-decreasing <code>s1' &ge; s1</code>.</li>
      <li><strong>Linear HIT = Faster Solving</strong>: Addition has no branching, giving 10x speedup over ArrayMax's branching max operation.</li>
      <li><strong>Non-Negative Assumption is Critical</strong>: Without <code>A[i] &ge; 0</code>, the MISS case would be fully unconstrained, making the encoding vacuous.</li>
      <li><strong>PCSAT Goal Interpretation</strong>: Violation UNSAT &rarr; property verified &check;; Forall-SAT checks confirm non-vacuity &check;</li>
    </ol>
    <hr>

    <h2>Comparison: Verified vs Vacuous</h2>
    <table>
      <thead>
        <tr><th>Algorithm</th><th>HIT Type</th><th>UNSAT Time</th><th>Genuine?</th></tr>
      </thead>
      <tbody>
        <tr><td><strong>ArraySum</strong></td><td>Explicit (<code>s1' = s1 + wk1</code>)</td><td>47 seconds</td><td>Yes &check;</td></tr>
        <tr><td><strong>ArrayMax</strong></td><td>Explicit (<code>m1' = max(m1, wk1)</code>)</td><td>8m 35s</td><td>Yes &check;</td></tr>
        <tr><td><strong>Dijkstra</strong></td><td>Abstract (<code>dv1' &ge; 0</code> = MISS!)</td><td>14 seconds</td><td>No &cross; (vacuous)</td></tr>
      </tbody>
    </table>
    <p><strong>Pattern</strong>: Explicit HIT + non-decreasing MISS &rarr; genuine verification. Abstract HIT (identical to MISS) &rarr; vacuous UNSAT.</p>
  </div>

  <!-- ============ DETAILED TUTORIAL PANEL ============ -->
  <div id="panel-detailed" class="panel content">
    <h1>ArraySum Monotonicity: Verification with Relational Cell Morphing</h1>
    <h3>A step-by-step tutorial explaining the PCSAT encoding for verifying monotonicity of array summation, including the discovery of PCSAT goal semantics and the vacuous UNSAT failure mode.</h3>
    <hr>

    <h2>Verification Results</h2>
    <h3>Asynchronous Model (two counters + scheduler)</h3>
    <table>
      <thead><tr><th>Goal</th><th>Result</th><th>Time</th><th>Meaning</th></tr></thead>
      <tbody>
        <tr><td><code>s1 &gt; s2</code> at termination</td><td><strong>UNSAT</strong></td><td>47.2s</td><td><strong>Monotonicity VERIFIED &check;</strong></td></tr>
        <tr><td><code>s1 &gt; s2</code> mid-execution (i1 &gt; i2)</td><td><strong>SAT</strong></td><td>12.5s</td><td>Vacuous SAT (TT-only schedule)</td></tr>
        <tr><td><code>s1 &le; s2</code> at termination</td><td>timeout</td><td>10+ hrs</td><td>See performance note below</td></tr>
        <tr><td><code>s1 &ge; 0</code> at termination</td><td><strong>SAT</strong></td><td>17s</td><td><strong>Non-vacuity confirmed &check;</strong></td></tr>
        <tr><td><code>n &gt; 0</code> at termination</td><td><strong>SAT</strong></td><td>12s</td><td><strong>Non-vacuity confirmed &check;</strong></td></tr>
      </tbody>
    </table>
    <div class="info-box">
      <strong>Performance note</strong>: The terminal SAT query (<code>s1 &le; s2</code> at termination) does not terminate. This is the same PCSAT asymmetry seen in ArrayMax &mdash; the MISS case <code>s1' &ge; s1</code> leaves the state space unbounded, making concrete witness search intractable. For non-vacuity checking, use <strong>forall-SAT checks</strong> (<code>s1 &ge; 0</code> and <code>n &gt; 0</code>).
    </div>
    <div class="info-box purple">
      <strong>Speed note</strong>: ArraySum (47s) verifies <strong>10x faster</strong> than ArrayMax (8m 35s) despite identical structure. The difference: ArraySum's HIT is a single linear expression (<code>s1' = s1 + wk1</code>) while ArrayMax's HIT is a 4-branch max operation. Fewer disjuncts = faster solver.
    </div>
    <hr>

    <h2>Part 1: The Algorithm</h2>
<pre><code>ArraySum(A: array, n: size)
    s := 0
    for i = 0 to n-1:
        s := s + A[i]
    return s</code></pre>
    <h3>Key Observations</h3>
    <ol>
      <li><strong>Scans left to right</strong>: Fixed iteration order, independent of data values</li>
      <li><strong>Running sum is non-decreasing</strong>: <code>s' = s + A[i] &ge; s</code> when <code>A[i] &ge; 0</code></li>
      <li><strong>Output depends on all elements</strong>: Every element contributes additively</li>
    </ol>
    <h3>Comparison with ArrayMax</h3>
<pre><code>ArrayMax:  m := A[0]; for i: m = max(m, A[i])     &larr; branching update
ArraySum:  s := 0;    for i: s = s + A[i]          &larr; linear update</code></pre>
    <p>Same iteration structure, different accumulation. The max operation branches (keep old vs take new); addition is unconditional. This difference drives a <strong>10x solver speedup</strong>.</p>
    <hr>

    <h2>Part 2: The Property &mdash; Monotonicity</h2>
<pre><code>PROPERTY: Monotonicity under pointwise ordering

&forall;i. A1[i] &le; A2[i]  &rArr;  ArraySum(A1) &le; ArraySum(A2)
    ~~~~~~~~~~~~~~~~     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    INPUT: every element     OUTPUT: sum of A1
    of A1 &le; corr. in A2     &le; sum of A2</code></pre>

    <h3>Assumption: Non-Negative Values</h3>
    <div class="info-box">
      <strong>ASSUMPTION:</strong> <code>&forall;i. A[i] &ge; 0</code><br><br>
      This ensures the running sum is non-decreasing (<code>s' = s + A[i] &ge; s</code>), which gives the MISS case enough information for the solver. Without this, MISS would be fully unconstrained and the encoding becomes vacuous.
    </div>

    <h3>Why Is This True? (Informal Proof)</h3>
<pre><code>ArraySum(A1) = &Sigma; A1[i]           (definition)
             = &Sigma; A1[i]           (split into terms)
             &le; &Sigma; A2[i]           (A1[i] &le; A2[i] for each term)
             = ArraySum(A2)       (definition)

Therefore: ArraySum(A1) &le; ArraySum(A2).  QED.</code></pre>
    <p>Even simpler than ArrayMax &mdash; no need to reason about which element is the max. Each term is pointwise smaller, so the sum is smaller.</p>

    <h3>Example</h3>
<pre><code>A1 = [3, 1, 7, 2, 5]    &rarr;  sum(A1) = 18
A2 = [4, 3, 9, 2, 8]    &rarr;  sum(A2) = 26

Pointwise: 3&le;4, 1&le;3, 7&le;9, 2&le;2, 5&le;8  &check;
Result:    18 &le; 26  &check;</code></pre>
    <hr>

    <h2>Part 3: How ArraySum Compares to ArrayMax</h2>
    <p>Both are monotonicity proofs using relational cell morphing. Same framework, different accumulation operation.</p>
    <table>
      <thead><tr><th>Aspect</th><th>ArrayMax</th><th>ArraySum</th></tr></thead>
      <tbody>
        <tr><td>Update</td><td><code>m = max(m, A[i])</code> &mdash; branching</td><td><code>s = s + A[i]</code> &mdash; linear</td></tr>
        <tr><td>HIT encoding</td><td>4 sub-cases (max &times; max)</td><td>1 expression (<code>s1' = s1 + wk1</code>)</td></tr>
        <tr><td>MISS encoding</td><td><code>m1' &ge; m1</code></td><td><code>s1' &ge; s1</code></td></tr>
        <tr><td>Non-negative assumption</td><td>Needed (for MISS non-decreasing)</td><td>Needed (for MISS non-decreasing)</td></tr>
        <tr><td>UNSAT time</td><td>8m 35s (131 iterations)</td><td><strong>47s</strong> (88 iterations)</td></tr>
        <tr><td>Variables</td><td>8</td><td>8</td></tr>
        <tr><td>Structure</td><td>Identical</td><td>Identical</td></tr>
      </tbody>
    </table>

    <h3>Why 10x Faster?</h3>
    <p>The HIT case determines solver complexity:</p>
<pre><code>ArrayMax HIT:  ((m1 &ge; wk1 and m1' = m1) or (wk1 &gt; m1 and m1' = wk1)) and
               ((m2 &ge; wk2 and m2' = m2) or (wk2 &gt; m2 and m2' = wk2))
                     &darr;
               4 disjunctive sub-cases in TT (2 &times; 2 for run1 &times; run2)

ArraySum HIT:  s1' = s1 + wk1 and s2' = s2 + wk2
                     &darr;
               1 case (pure linear arithmetic)</code></pre>
    <p><strong>Lesson: Linear operations are faster than branching operations for CHC solvers.</strong></p>
    <hr>

    <h2>Part 4: Relational Cell Morphing Setup</h2>
<pre><code>TWO DISTINGUISHED CELLS

1. INPUT CELL (Array Element)
   k:       Distinguished index (SYMBOLIC)
            Universally quantified over all positions
   wk1:     A1[k] &mdash; value in array 1
   wk2:     A2[k] &mdash; value in array 2
   PRECONDITION: 0 &le; wk1 &le; wk2 (non-negative + monotone)
   IMPLICIT: &forall;j &ne; k. 0 &le; A1[j] &le; A2[j]
   k, wk1, wk2 NEVER CHANGE

2. OUTPUT CELL (Running Sum)
   s1:      Current sum in run 1
   s2:      Current sum in run 2
   POSTCONDITION: s1 &le; s2 (monotonicity)
   s1, s2 CAN CHANGE (non-decreasing)</code></pre>
    <div class="info-box purple">
      <strong>What's missing compared to robustness:</strong>
      <ul>
        <li>No sign bits (<code>bk</code>, <code>bc</code>) &mdash; direction is known</li>
        <li>No epsilon &mdash; no quantitative bound</li>
        <li>No hop counts &mdash; no predecessor tracking needed</li>
        <li>Leaner state: 8 variables (vs 13 for Dijkstra robustness)</li>
      </ul>
    </div>
    <hr>

    <h2>Part 5: HIT/MISS Abstraction</h2>
    <p>When processing element <code>i</code>:</p>
    <div class="info-box">
      <strong>HIT: We process the DISTINGUISHED element k</strong><br><br>
<pre style="border:none;margin:0;padding:0;background:transparent"><code>s1' = s1 + wk1     &larr; We know EXACTLY what happens!
s2' = s2 + wk2

Both operands known:
  s1 and s2 from invariant
  wk1 and wk2 from input cell

Monotonicity preserved (when s1 &le; s2 holds):
  s1 &le; s2  and  wk1 &le; wk2
  &rarr; s1 + wk1 &le; s2 + wk2
  &rarr; s1' &le; s2'  &check;

NO sub-cases needed! (Unlike ArrayMax's 4 sub-cases)
Addition is monotone in both arguments directly.</code></pre>
    </div>
    <div class="info-box">
      <strong>MISS: We process some OTHER element (not k)</strong><br><br>
<pre style="border:none;margin:0;padding:0;background:transparent"><code>s1' = s1 + A1[i]     &larr; A1[i] UNKNOWN but &ge; 0
s2' = s2 + A2[i]     &larr; A2[i] UNKNOWN but &ge; 0

What we know:
  A1[i] &ge; 0           (non-negative assumption)
  A2[i] &ge; 0           (non-negative assumption)
  A1[i] &le; A2[i]       (universal precondition, implicit)
  s1' &ge; s1            (adding non-negative value)
  s2' &ge; s2            (adding non-negative value)

In ASYNCHRONOUS model:
  Runs at different indices &rarr; s1' &le; s2 can BREAK!
  (no transition constraint &mdash; solver must find invariant)</code></pre>
    </div>
    <p><strong>Key difference from ArrayMax</strong>: HIT is a single linear expression. No branching, no sub-cases. This makes the solver's job dramatically easier (47s vs 8m 35s).</p>
    <p><strong>Similarity to ArrayMax</strong>: MISS is identical: <code>output' &ge; output</code> (non-decreasing). The non-negative assumption drives both.</p>
    <hr>

    <h2>Part 6: HIT is Fully Explicit</h2>
    <p>The <code>s + wk</code> operation depends ONLY on known values:</p>
<pre><code>ArraySum HIT:   s1' = s1 + wk1        &larr; s1 from invariant, wk1 from input cell
ArrayMax HIT:   m1' = max(m1, wk1)    &larr; m1 from invariant, wk1 from input cell
Kruskal HIT:    c1' = c1 + wk1        &larr; c1 from invariant, wk1 from input cell
Dijkstra HIT:   dv1' = d1[u] + wk1    &larr; d1[u] UNTRACKED!</code></pre>
    <p>ArraySum, ArrayMax, and Kruskal all have fully explicit HIT cases &mdash; the distinguished cell value completely determines the transition. Dijkstra's HIT depends on an untracked predecessor distance <code>d[u]</code>, causing vacuous results.</p>
    <hr>

    <h2>Part 7: State Variables</h2>
<pre><code>Inv(i1, i2, k, wk1, wk2, s1, s2, n)</code></pre>
    <table>
      <thead><tr><th>Variable</th><th>Type</th><th>Meaning</th><th>Changes?</th></tr></thead>
      <tbody>
        <tr><td><code>i1</code></td><td>int</td><td>Current index in run 1</td><td>Yes (0 &rarr; n)</td></tr>
        <tr><td><code>i2</code></td><td>int</td><td>Current index in run 2</td><td>Yes (0 &rarr; n)</td></tr>
        <tr><td><code>k</code></td><td>int</td><td>Distinguished element index</td><td><strong>Never</strong></td></tr>
        <tr><td><code>wk1</code></td><td>real</td><td>A1[k]</td><td><strong>Never</strong></td></tr>
        <tr><td><code>wk2</code></td><td>real</td><td>A2[k]</td><td><strong>Never</strong></td></tr>
        <tr><td><code>s1</code></td><td>real</td><td>Running sum in run 1</td><td>Yes (non-decreasing)</td></tr>
        <tr><td><code>s2</code></td><td>real</td><td>Running sum in run 2</td><td>Yes (non-decreasing)</td></tr>
        <tr><td><code>n</code></td><td>int</td><td>Array size</td><td><strong>Never</strong></td></tr>
      </tbody>
    </table>
    <p><strong>8 variables.</strong> Same as ArrayMax async. Same as all async monotonicity encodings.</p>

    <h3>What's Missing Compared to Kruskal Robustness (11 variables)</h3>
    <table>
      <thead><tr><th>Dropped</th><th>Why</th></tr></thead>
      <tbody>
        <tr><td><code>bk:bool</code></td><td>Direction known: wk1 &le; wk2</td></tr>
        <tr><td><code>bc:bool</code></td><td>Direction known: s1 &le; s2</td></tr>
        <tr><td><code>eps</code></td><td>No quantitative bound</td></tr>
      </tbody>
    </table>
    <hr>

    <h2>Part 8: Initialization</h2>
<pre><code>Inv(i1, i2, k, wk1, wk2, s1, s2, n) :-
    i1 = 0, i2 = 0,
    n &gt; 0,
    0 &le; k, k &lt; n,
    0 &le; wk1, wk1 &le; wk2,
    s1 = 0, s2 = 0.</code></pre>
    <h4>What This Says</h4>
    <ol>
      <li><code>i1 = 0, i2 = 0</code>: No elements processed yet</li>
      <li><code>n &gt; 0</code>: Non-empty array</li>
      <li><code>0 &le; k, k &lt; n</code>: Valid index</li>
      <li><code>0 &le; wk1, wk1 &le; wk2</code>: Monotone input (non-negative values)</li>
      <li><code>s1 = 0, s2 = 0</code>: Running sum starts at 0</li>
    </ol>
    <h4>The Non-Negative Constraint</h4>
    <p><code>0 &le; wk1, wk1 &le; wk2</code> encodes TWO things: the monotonicity precondition (<code>wk1 &le; wk2</code>) AND the non-negative assumption (<code>0 &le; wk1</code>). The non-negative assumption is critical &mdash; it's what makes <code>s1' &ge; s1</code> in MISS meaningful.</p>

    <h4>Comparison with Kruskal Initialization</h4>
<pre><code>Kruskal:   (bk and 0 &le; wk2-wk1 and wk2-wk1 &le; eps) or
           (!bk and 0 &le; wk1-wk2 and wk1-wk2 &le; eps)
                         &darr;
ArraySum:  0 &le; wk1, wk1 &le; wk2</code></pre>
    <p>No sign bit, no epsilon. Just direct ordering + non-negativity constraints.</p>
    <hr>

    <h2>Part 9: Transitions</h2>

    <h3>TF Transition &mdash; Only Run 1 Steps</h3>
<pre><code>Inv(i1', i2, k, wk1, wk2, s1', s2, n) :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchTF(i1, i2, k, wk1, wk2, s1, s2, n),
    (
        (* HIT: process distinguished element k *)
        i1 &lt; n and i1 = k and i1' = i1 + 1 and
        s1' = s1 + wk1
    ) or (
        (* MISS: process other element &mdash; value unknown but non-negative *)
        i1 &lt; n and i1 &lt;&gt; k and i1' = i1 + 1 and
        s1' &ge; s1
    ) or (
        (* Finished *)
        i1 &ge; n and i1' = i1 and s1' = s1
    ).</code></pre>

    <h4>Case 1: HIT &mdash; Process Distinguished Element k</h4>
    <p><code>s1' = s1 + wk1</code>: Encodes <code>s1' = s1 + A1[k]</code> exactly. No sub-cases needed &mdash; addition is a single expression.</p>

    <h4>Case 2: MISS &mdash; Process Other Element</h4>
    <p><code>s1' &ge; s1</code>: Value of <code>A1[i]</code> is unknown but non-negative. The sum doesn't decrease.</p>

    <h4>Case 3: Finished &mdash; Stutter</h4>
    <p>All elements processed. State unchanged.</p>

    <h4>What's NOT Here: No Monotone Bound</h4>
    <p>We <strong>cannot</strong> put <code>s1' &le; s2'</code> as a transition constraint. When run 1 is ahead (<code>i1 &gt; i2</code>), it has accumulated more values, so <code>s1 &gt; s2</code> can happen. The monotone bound only holds at termination. The solver must discover this conditional invariant on its own.</p>

    <h3>FT Transition &mdash; Only Run 2 Steps</h3>
<pre><code>Inv(i1, i2', k, wk1, wk2, s1, s2', n) :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchFT(i1, i2, k, wk1, wk2, s1, s2, n),
    (
        (* HIT *)
        i2 &lt; n and i2 = k and i2' = i2 + 1 and
        s2' = s2 + wk2
    ) or (
        (* MISS *)
        i2 &lt; n and i2 &lt;&gt; k and i2' = i2 + 1 and
        s2' &ge; s2
    ) or (
        (* Finished *)
        i2 &ge; n and i2' = i2 and s2' = s2
    ).</code></pre>
    <p>Same structure as TF, but for run 2. Again, no monotone bound.</p>

    <h3>TT Transition &mdash; Both Step</h3>
<pre><code>Inv(i1', i2', k, wk1, wk2, s1', s2', n) :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchTT(i1, i2, k, wk1, wk2, s1, s2, n),
    (* Run 1 *)
    (
        i1 &lt; n and i1 = k and i1' = i1 + 1 and
        s1' = s1 + wk1
    ) or (
        i1 &lt; n and i1 &lt;&gt; k and i1' = i1 + 1 and
        s1' &ge; s1
    ) or (
        i1 &ge; n and i1' = i1 and s1' = s1
    ),
    (* Run 2 *)
    (
        i2 &lt; n and i2 = k and i2' = i2 + 1 and
        s2' = s2 + wk2
    ) or (
        i2 &lt; n and i2 &lt;&gt; k and i2' = i2 + 1 and
        s2' &ge; s2
    ) or (
        i2 &ge; n and i2' = i2 and s2' = s2
    ).</code></pre>
    <p>Cartesian product of run 1 and run 2 cases. Run 1 and run 2 are at <strong>different</strong> indices in general (<code>i1 &ne; i2</code>), so at most one can be at index <code>k</code>. No monotone bound. No epsilon bound. The transition constraints are purely structural.</p>
    <hr>

    <h2>Part 10: Scheduler and Fairness</h2>
<pre><code>i1 &lt; n :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchTF(i1, i2, k, wk1, wk2, s1, s2, n),
    i2 &lt; n.

i2 &lt; n :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchFT(i1, i2, k, wk1, wk2, s1, s2, n),
    i1 &lt; n.

SchTF(i1, i2, k, wk1, wk2, s1, s2, n),
SchFT(i1, i2, k, wk1, wk2, s1, s2, n),
SchTT(i1, i2, k, wk1, wk2, s1, s2, n) :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    i1 &lt; n or i2 &lt; n.</code></pre>
    <p>Standard pattern, identical to all previous asynchronous encodings. Ensures both runs eventually complete.</p>
    <hr>

    <h2>Part 11: Goal and Results</h2>
<pre><code>(* Check if violation is reachable at termination *)
s1 &gt; s2 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n &le; i1, n &le; i2.</code></pre>
    <p>At termination, is <code>s1 &gt; s2</code> reachable? "Termination" means both runs finished (<code>n &le; i1</code> and <code>n &le; i2</code>), regardless of the order they got there.</p>
    <p><strong>Result: UNSAT in 47.2 seconds, 88 iterations.</strong> PCSAT found an invariant!</p>
    <hr>

    <h2>Part 12: The PCSAT Semantics Discovery</h2>
    <p>During sanity checking of ArraySum, we discovered something fundamental about how PCSAT interprets constraint-head goals.</p>

    <h3>The Question</h3>
    <p>When PCSAT returns SAT or UNSAT for a goal clause like <code>C :- Inv(...), body</code>, what does it mean?</p>
<pre><code>Interpretation A (Reachability):
  SAT  = there EXISTS a reachable state satisfying body where C holds
  UNSAT = NO reachable state satisfying body has C

Interpretation B (Forall):
  SAT  = C holds at ALL reachable states satisfying body
  UNSAT = C does NOT hold at all such states</code></pre>

    <h3>The Disambiguation Experiment (D-tests)</h3>
    <p>We designed tests with known answers under each interpretation:</p>
    <table>
      <thead><tr><th>Test</th><th>Goal</th><th>Reachability</th><th>Forall</th><th>Actual</th></tr></thead>
      <tbody>
        <tr><td>D1</td><td><code>n &gt; 0</code></td><td>SAT</td><td>SAT</td><td><strong>SAT</strong> (12s)</td></tr>
        <tr><td>D2</td><td><code>s1 &lt; 0</code></td><td>UNSAT</td><td>UNSAT</td><td><strong>UNSAT</strong> (1:11)</td></tr>
        <tr><td>D3</td><td><code>wk1 &gt; 0</code></td><td><strong>SAT</strong></td><td><strong>UNSAT</strong></td><td><strong>UNSAT</strong> (40s)</td></tr>
      </tbody>
    </table>
    <p><strong>D3 returned UNSAT &rarr; PCSAT uses forall semantics.</strong></p>

    <h3>Confirmed Semantics</h3>
<pre><code>C :- Inv(...), body.

SAT   = C holds at ALL reachable states satisfying body   (universal truth)
UNSAT = C does NOT hold at all such states                (exists counterexample)</code></pre>

    <h3>Re-interpreting the Violation Goal</h3>
    <p>The violation goal <code>s1 &gt; s2</code> returned UNSAT. Under forall semantics, this means: "it is NOT the case that ALL terminated states have <code>s1 &gt; s2</code>."</p>
    <p>This sounds weaker than "<code>s1 &le; s2</code> always." But in the CHC framework, UNSAT has a stronger meaning: <strong>no inductive invariant exists that makes the violation universal.</strong> The solver tried every possible over-approximation of reachable states and couldn't find one where all terminated states satisfy <code>s1 &gt; s2</code>. Combined with cell morphing soundness, this proves the property.</p>
    <hr>

    <h2>Part 13: Sanity Checking &mdash; The Dijkstra Lesson</h2>
    <p>After the PCSAT semantics discovery, we needed to revisit sanity checking.</p>

    <h3>The Dijkstra Vacuity Story</h3>
    <p>We encoded Dijkstra shortest path monotonicity with the same async framework. The violation goal returned <strong>UNSAT in 14 seconds</strong>. Five sanity checks revealed the truth:</p>
    <div class="info-box">
      <strong>DIJKSTRA SANITY CHECKS</strong><br><br>
      Check 1: <code>dv1 &gt; 0</code> at termination &rarr; UNSAT (dv1 stuck at 0!)<br>
      Check 2: <code>dv1 &ne; dv2</code> at termination &rarr; UNSAT (both = 0!)<br>
      Check 3: <code>dv2 &gt; dv1</code> at termination &rarr; UNSAT (symmetric &mdash; both 0)<br>
      Check 4: <code>dv1 &gt; dv2</code> mid-execution &rarr; SAT (non-trivial mid-exec)<br>
      Check 5: <code>h1 &gt; 0</code> at termination &rarr; UNSAT (relaxation DEAD!)<br><br>
      <strong>VERDICT:</strong> The solver proved <code>0 &gt; 0</code> is false, NOT <code>d1(v) &le; d2(v)</code>. The UNSAT was VACUOUS.
    </div>

    <h3>Root Cause</h3>
    <p>Dijkstra's HIT is <strong>abstract</strong> &mdash; <code>dv1' &ge; 0</code> (identical to MISS) &mdash; because the predecessor distance <code>d[u]</code> is untracked. The solver found an invariant where distances stay at 0 through termination.</p>

    <h3>ArraySum vs Dijkstra: Why ArraySum Is Non-Vacuous</h3>
    <div class="info-box success">
      <strong>ArraySum (NON-VACUOUS):</strong><br>
      HIT: <code>s1' = s1 + wk1</code> &larr; EXPLICIT. Mandatory (0 &le; k &lt; n).<br>
      After HIT with wk1=5: s1 &ge; 5. Solver CANNOT ignore this.<br>
      Non-vacuity: <code>s1 &ge; 0</code> at termination &rarr; SAT (17s) &check;<br><br>
      <strong>Dijkstra (VACUOUS):</strong><br>
      HIT: <code>dv1' &ge; 0</code> &larr; ABSTRACT. Same as MISS!<br>
      Solver CAN pretend relaxation never fires (dv1 stays at 0).<br>
      Non-vacuity: <code>dv1 &gt; 0</code> at termination &rarr; UNSAT (stuck at 0!) &cross;<br><br>
      <strong>RULE:</strong> An encoding is non-vacuous when HIT FORCES the output to change in a way the solver cannot ignore. Explicit HIT &rarr; non-vacuous. Abstract HIT (= MISS) &rarr; vacuous.
    </div>
    <hr>

    <h2>Part 14: The Complete Sanity Check Evidence</h2>
    <h3>ArraySum Results</h3>
    <table>
      <thead><tr><th>#</th><th>Goal</th><th>Result</th><th>Time</th><th>Interpretation (forall semantics)</th></tr></thead>
      <tbody>
        <tr><td>1</td><td><code>s1 &gt; s2</code> at termination</td><td><strong>UNSAT</strong></td><td>47s</td><td><strong>Monotonicity verified</strong></td></tr>
        <tr><td>2</td><td><code>s1 &le; s2</code> at termination</td><td>timeout</td><td>&mdash;</td><td>Terminal SAT (unbounded MISS)</td></tr>
        <tr><td>3</td><td><code>s1 &gt; s2</code> at i1 &gt; i2</td><td>SAT</td><td>12.5s</td><td>Vacuous SAT (TT-only schedule)</td></tr>
        <tr><td>A</td><td><code>s1 &gt; 0</code> at termination</td><td>UNSAT</td><td>15s</td><td>Not universal (wk1=0 case). NOT vacuity.</td></tr>
        <tr><td>B</td><td><code>s2 &gt; s1</code> at termination</td><td>UNSAT</td><td>4:23</td><td>Not universal (wk1=wk2 case). Expected.</td></tr>
        <tr><td>D1</td><td><code>n &gt; 0</code> at termination</td><td><strong>SAT</strong></td><td>12s</td><td>Universal truth. <strong>Non-vacuity confirmed.</strong></td></tr>
        <tr><td>D2</td><td><code>s1 &lt; 0</code> at termination</td><td>UNSAT</td><td>1:11</td><td>Not universal (s1 &ge; 0). Expected.</td></tr>
        <tr><td>D3</td><td><code>wk1 &gt; 0</code> at termination</td><td>UNSAT</td><td>40s</td><td>Not universal (wk1=0). <strong>Semantics decider.</strong></td></tr>
        <tr><td>F</td><td><code>s1 &ge; 0</code> at termination</td><td><strong>SAT</strong></td><td>17s</td><td>Universal truth. <strong>Non-vacuity confirmed.</strong></td></tr>
      </tbody>
    </table>

    <h3>The Sanity Check Recipe</h3>
<pre><code>After getting UNSAT on a violation goal:

Step 1: Run a universally-true property.
        s1 &ge; 0 :- Inv(...), n &le; i1, n &le; i2.
        Expected: SAT

Step 2: If SAT &rarr; encoding is non-vacuous. DONE.
        If UNSAT &rarr; encoding may be vacuous. Investigate.

Step 3: (If needed) Run D-style tests to understand what the solver sees.</code></pre>
    <p>For ArraySum: violation UNSAT (47s) + <code>s1 &ge; 0</code> SAT (17s) = <strong>genuinely verified, non-vacuous.</strong></p>
    <hr>

    <h2>Part 15: The Mid-Execution SAT Puzzle</h2>
    <p>The mid-execution test <code>s1 &gt; s2 :- Inv, i1 &gt; i2</code> returned SAT in 12.5 seconds.</p>
    <p>Under forall semantics, SAT means <code>s1 &gt; s2</code> holds at <strong>ALL</strong> reachable states with <code>i1 &gt; i2</code>. How can that be universally true?</p>

    <h3>The Solver's Trick</h3>
    <p>PCSAT found an invariant where the <strong>scheduler only uses TT</strong> (both runs step together). With TT-only:</p>
<pre><code>Init:     i1 = 0, i2 = 0
After TT: i1 = 1, i2 = 1
After TT: i1 = 2, i2 = 2
...
Terminal: i1 = n, i2 = n</code></pre>
    <p>Under this schedule, <code>i1 = i2</code> <strong>always</strong>. The body condition <code>i1 &gt; i2</code> is <strong>never satisfied</strong>. The implication <code>Inv &and; i1 &gt; i2 &rarr; s1 &gt; s2</code> is <strong>vacuously true</strong> (false premise &rarr; anything).</p>

    <h3>Lesson</h3>
    <p>SAT of a goal with a restrictive body condition can be vacuously true. The solver found a valid (but restrictive) invariant that avoids the body condition entirely. This is why mid-execution SAT is <strong>not a reliable non-vacuity check</strong> &mdash; use forall-SAT checks (<code>s1 &ge; 0</code>, <code>n &gt; 0</code>) instead.</p>
    <hr>

    <h2>Part 16: Why UNSAT Is (Genuinely) Possible</h2>

    <h3>The Naive Argument for SAT</h3>
<pre><code>Init:    i1=0, i2=0, s1=0, s2=0
TF MISS: i1=1, s1'=1000000          &larr; legal: s1' &ge; 0 &check;
TF MISS: i1=2, s1'=2000000          &larr; legal: s1' &ge; 1000000 &check;
... (repeat until i1=n) ...
FT MISS: i2=1, s2'=0                &larr; legal: s2' &ge; 0 &check;
... (repeat until i2=n) ...
Terminal: s1=2000000 &gt; s2=0          &rarr; violation!</code></pre>
    <p>Every step satisfies the transition constraints. So why is it UNSAT?</p>

    <h3>The Resolution</h3>
    <p>PCSAT doesn't simulate executions &mdash; it searches for an <strong>inductive invariant</strong> that: (1) contains all initial states, (2) is closed under all transitions, and (3) does not intersect the goal states.</p>
    <p>The key insight is that <code>k</code> is <strong>universally quantified</strong>. The invariant must work for ALL choices of <code>k</code> simultaneously. For any element <code>j</code> that inflates <code>s1</code> (via <code>A1[j]</code>), the same element also inflates <code>s2</code> (via <code>A2[j] &ge; A1[j]</code>). The MISS abstraction (<code>s' &ge; s</code>) is symmetric between the two runs &mdash; any growth in <code>s1</code> is matched by at least as much potential growth in <code>s2</code>.</p>
    <hr>

    <h2>Part 17: Comparison &mdash; ArraySum vs ArrayMax vs Dijkstra</h2>
    <p>Three algorithms with the same async cell morphing framework, three different outcomes:</p>
    <table>
      <thead><tr><th>Aspect</th><th>ArraySum</th><th>ArrayMax</th><th>Dijkstra</th></tr></thead>
      <tbody>
        <tr><td>HIT</td><td><code>s += wk</code></td><td><code>m = max(m, wk)</code></td><td><code>dv' &ge; 0</code> (= MISS!)</td></tr>
        <tr><td>MISS</td><td><code>s' &ge; s</code></td><td><code>m' &ge; m</code></td><td><code>dv' &ge; 0</code></td></tr>
        <tr><td>UNSAT time</td><td><strong>47 seconds</strong></td><td>8m 35s</td><td>14 seconds</td></tr>
        <tr><td>Genuine?</td><td><strong>Yes &check;</strong></td><td><strong>Yes &check;</strong></td><td><strong>No &cross; (vacuous)</strong></td></tr>
        <tr><td>Non-vacuity</td><td><code>s1 &ge; 0</code> SAT</td><td>mid-exec SAT</td><td>dv1 = 0 always</td></tr>
        <tr><td>Key factor</td><td>Linear HIT (fast)</td><td>Branching HIT (slow)</td><td>Abstract HIT (trivial)</td></tr>
      </tbody>
    </table>
    <div class="info-box purple">
      <strong>PATTERN:</strong><br>
      Explicit HIT + non-decreasing MISS &rarr; genuine verification<br>
      Abstract HIT (= MISS) &rarr; vacuous UNSAT
    </div>
    <hr>

    <h2>Part 18: Visual Summary</h2>
<pre><code>INPUT: Arrays A1, A2 with A1[i] &le; A2[i] for all i, A[i] &ge; 0

Distinguished element k: wk1 = A1[k], wk2 = A2[k]
  PRECONDITION: 0 &le; wk1 &le; wk2
  k, wk1, wk2 NEVER CHANGE
              |
              v
  ArraySum ALGORITHM
    For each element:  s = s + A[i]
      HIT (i = k):   s1' = s1 + wk1  &larr; EXPLICIT!
                      s2' = s2 + wk2
                      Monotonicity: wk1 &le; wk2 &rarr; s1' &le; s2'
      MISS (i &ne; k):  s1' = s1 + ???   &larr; Unknown, non-negative
                      s2' = s2 + ???
                      Only know: s1' &ge; s1, s2' &ge; s2
              |
              v
OUTPUT: sum(A1) and sum(A2)
  POSTCONDITION: sum(A1) &le; sum(A2)

  VERIFIED! &check;
    Asynchronous:   UNSAT in 47s (88 iterations)
    Non-vacuity:    s1 &ge; 0 SAT (17s) + n &gt; 0 SAT (12s)</code></pre>
    <hr>

    <h2>Part 19: Test Queries</h2>
    <h3>Practical Guidance</h3>
    <p>For the asynchronous model, terminal SAT queries (like <code>s1 &le; s2</code> at termination) may not terminate due to unbounded state space in the MISS case. Use <strong>forall-SAT checks</strong> for non-vacuity instead.</p>
<pre><code>(* PRIMARY: Violation - expected UNSAT *)
s1 &gt; s2 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n &le; i1, n &le; i2.

(* NON-VACUITY CHECK 1: Universal truth - expected SAT *)
s1 &ge; 0 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n &le; i1, n &le; i2.

(* NON-VACUITY CHECK 2: Another universal truth - expected SAT *)
n &gt; 0 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n &le; i1, n &le; i2.

(* SEMANTICS TEST: wk1 &gt; 0 - UNSAT confirms forall semantics *)
(* CAUTION: Terminal SAT for s1 &le; s2 does NOT terminate *)</code></pre>
    <hr>

    <h2>Part 20: Key Takeaways</h2>
    <ol>
      <li><strong>ArraySum monotonicity is verified</strong>: UNSAT in 47 seconds, non-vacuity confirmed via <code>s1 &ge; 0</code> SAT (17s) and <code>n &gt; 0</code> SAT (12s).</li>
      <li><strong>Linear HIT = 10x faster than branching HIT</strong>: ArraySum (47s) vs ArrayMax (8m 35s). The <code>s += wk</code> expression has no sub-cases, giving the solver dramatically fewer disjuncts to close.</li>
      <li><strong>PCSAT uses forall semantics</strong>: The D-tests proved this definitively. SAT = universal truth; UNSAT = not universal. This affects the interpretation of ALL goals and sanity checks.</li>
      <li><strong>Mid-execution SAT is unreliable for non-vacuity</strong>: The solver can use a TT-only schedule to make body conditions vacuously unsatisfied. Use forall-SAT checks (<code>s1 &ge; 0</code>, <code>n &gt; 0</code>) instead.</li>
      <li><strong>Vacuous UNSAT is a real threat</strong>: Dijkstra's encoding proved <code>0 &gt; 0</code> is false, not monotonicity. The fix: after any UNSAT, run a universally-true property and check for SAT.</li>
      <li><strong>The non-negative assumption is critical</strong>: Without <code>0 &le; wk1</code>, MISS would be fully unconstrained, and the encoding would become vacuous. The assumption makes <code>s1' &ge; s1</code> informative.</li>
      <li><strong>Explicit HIT is the non-vacuity guarantee</strong>: When HIT forces a concrete change (<code>s1' = s1 + wk1</code>), the solver must account for it. When HIT is abstract (<code>dv1' &ge; 0</code>), the solver can ignore it.</li>
      <li><strong>UNSAT/SAT asymmetry for unbounded encodings</strong>: When MISS has no upper bound (only <code>s1' &ge; s1</code>), UNSAT is feasible but terminal SAT may not terminate. Use forall-SAT queries for non-vacuity checks.</li>
    </ol>
    <hr>

    <h2>References</h2>
    <ol>
      <li><strong>Chaudhuri, Gulwani, Lublinerman</strong> &mdash; "Continuity and Robustness of Programs" (CACM 2012)</li>
      <li><strong>Monniaux &amp; Gonnord</strong> &mdash; "Cell Morphing: From Array Programs to Array-Free Horn Clauses" (SAS 2016)</li>
      <li><strong>Unno, Terauchi, Kobayashi</strong> &mdash; "Constraint-based Relational Verification" (CAV 2021)</li>
      <li><strong>PCSAT Solver</strong> &mdash; Tool for solving predicate constraint satisfaction problems</li>
    </ol>
  </div>

  <!-- ============ SOURCE CODE PANEL ============ -->
  <div id="panel-source" class="panel">
    <div class="source-container">
      <div class="source-header">
        <span class="source-filename">monotone_arraysum_final.clp</span>
        <button class="copy-btn" onclick="copySource()">Copy to clipboard</button>
      </div>
      <div class="source-lines">
        <div class="line-numbers" id="line-nums"></div>
        <div class="source-code" id="source-code"></div>
      </div>
    </div>
  </div>
</main>

<script>
// Tab switching
function switchTab(el) {
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('panel-' + el.dataset.panel).classList.add('active');
}

// Source code content
const sourceCode = `
(*
ArraySum(A: array, n: size)
    s := 0
    for i = 0 to n-1:
        s := s + A[i]
    return s
*)

(*
PROPERTY: Monotonicity under pointwise ordering
  forall i. A1[i] <= A2[i]  ==>  ArraySum(A1) <= ArraySum(A2)

ASSUMPTION: All array values non-negative (A[i] >= 0 for all i).
  This is needed so that sum is non-decreasing during iteration (s' >= s),
  which gives the solver enough information in the MISS case.
  Without this, MISS transitions are fully unconstrained and the async
  model likely cannot close the invariant. A synchronized model would
  be needed for the general (possibly negative values) case.

================================================================================
ASYNCHRONOUS MODEL
================================================================================

Follows the ArrayMax monotonicity pattern exactly.
Distinguished cell k with values wk1 (in A1) and wk2 (in A2).

HIT (i = k): s1' = s1 + wk1  or  s2' = s2 + wk2  (explicit)
MISS (i != k): s1' >= s1  or  s2' >= s2  (non-decreasing, value unknown)
  The non-negative assumption ensures s' >= s.

State: i1, i2, k, wk1, wk2, s1, s2, n  (8 variables)
*)


(******************************************************************************)
(* INITIALIZATION                                                             *)
(******************************************************************************)

Inv(i1, i2, k, wk1, wk2, s1, s2, n) :-
    i1 = 0, i2 = 0,
    n > 0,
    0 <= k, k < n,
    0 <= wk1, wk1 <= wk2,
    s1 = 0, s2 = 0.


(******************************************************************************)
(* TF TRANSITION - Only run 1 steps                                           *)
(*                                                                            *)
(* HIT: s1' = s1 + wk1 (add known value at k)                                *)
(* MISS: s1' >= s1 (non-decreasing, value unknown but non-negative)           *)
(* Finished: stutter                                                          *)
(******************************************************************************)

Inv(i1', i2, k, wk1, wk2, s1', s2, n) :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchTF(i1, i2, k, wk1, wk2, s1, s2, n),
    (
        (* HIT: process distinguished element k *)
        i1 < n and i1 = k and i1' = i1 + 1 and
        s1' = s1 + wk1
    ) or (
        (* MISS: process other element \u2014 value unknown but non-negative *)
        i1 < n and i1 <> k and i1' = i1 + 1 and
        s1' >= s1
    ) or (
        (* Finished *)
        i1 >= n and i1' = i1 and s1' = s1
    ).


(******************************************************************************)
(* FT TRANSITION - Only run 2 steps                                           *)
(******************************************************************************)

Inv(i1, i2', k, wk1, wk2, s1, s2', n) :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchFT(i1, i2, k, wk1, wk2, s1, s2, n),
    (
        (* HIT *)
        i2 < n and i2 = k and i2' = i2 + 1 and
        s2' = s2 + wk2
    ) or (
        (* MISS *)
        i2 < n and i2 <> k and i2' = i2 + 1 and
        s2' >= s2
    ) or (
        (* Finished *)
        i2 >= n and i2' = i2 and s2' = s2
    ).


(******************************************************************************)
(* TT TRANSITION - Both runs step                                             *)
(*                                                                            *)
(* Run 1 and run 2 step independently at their respective positions.          *)
(* At most one can be at k (since i1 != i2 in general).                       *)
(******************************************************************************)

Inv(i1', i2', k, wk1, wk2, s1', s2', n) :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchTT(i1, i2, k, wk1, wk2, s1, s2, n),
    (* Run 1 *)
    (
        i1 < n and i1 = k and i1' = i1 + 1 and
        s1' = s1 + wk1
    ) or (
        i1 < n and i1 <> k and i1' = i1 + 1 and
        s1' >= s1
    ) or (
        i1 >= n and i1' = i1 and s1' = s1
    ),
    (* Run 2 *)
    (
        i2 < n and i2 = k and i2' = i2 + 1 and
        s2' = s2 + wk2
    ) or (
        i2 < n and i2 <> k and i2' = i2 + 1 and
        s2' >= s2
    ) or (
        i2 >= n and i2' = i2 and s2' = s2
    ).


(******************************************************************************)
(* SCHEDULER FAIRNESS                                                         *)
(******************************************************************************)

i1 < n :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchTF(i1, i2, k, wk1, wk2, s1, s2, n),
    i2 < n.

i2 < n :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    SchFT(i1, i2, k, wk1, wk2, s1, s2, n),
    i1 < n.

SchTF(i1, i2, k, wk1, wk2, s1, s2, n),
SchFT(i1, i2, k, wk1, wk2, s1, s2, n),
SchTT(i1, i2, k, wk1, wk2, s1, s2, n) :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    i1 < n or i2 < n.


(******************************************************************************)
(* DEFINITIVE NON-VACUITY CHECK                                               *)
(*                                                                            *)
(* Under forall semantics, SAT = holds at ALL terminated states.              *)
(* s1 >= 0 is always true (init s1=0, MISS s1'>=s1, HIT s1'=s1+wk1>=s1).   *)
(* SAT here proves: terminated states exist AND have meaningful s1 values.    *)
(*                                                                            *)
(* RESULT: SAT, 17s \u2014 encoding is NON-VACUOUS.                               *)
(******************************************************************************)

(* s1 >= 0 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n <= i1, n <= i2.
sat   17s *)


(******************************************************************************)
(* ALL TEST RESULTS                                                           *)
(******************************************************************************)

(*
(* Violation goal \u2014 UNSAT = monotonicity VERIFIED *)
s1 > s2 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n <= i1, n <= i2.
unsat,88   47.222s

(* Mid-execution \u2014 SAT = non-trivial states exist *)
s1 > s2 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    i1 > i2.
sat,29   12.513s

(* Terminal SAT \u2014 timeout (unbounded MISS, see pcsat_performance_notes) *)
s1 <= s2 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n <= i1, n <= i2.
timeout

(* Check A: s1 > 0 at termination \u2014 UNSAT *)
(* Forall semantics: "not all terminated states have s1 > 0" *)
(* Expected: wk1 = 0 gives s1 = 0, so not universal. NOT vacuity. *)
s1 > 0 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n <= i1, n <= i2.
unsat   15.182s

(* Check B: s2 > s1 at termination \u2014 UNSAT *)
(* Forall semantics: "not all terminated states have s2 > s1" *)
(* Expected: wk1 = wk2 gives s1 = s2, so not universal. NOT vacuity. *)
s2 > s1 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n <= i1, n <= i2.
unsat,96   4:23s

(* D1: n > 0 \u2014 SAT. Confirms forall semantics: n > 0 always. *)
n > 0 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n <= i1, n <= i2.
sat   12s

(* D2: s1 < 0 \u2014 UNSAT. Not all states have s1 < 0 (s1 >= 0 always). *)
s1 < 0 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n <= i1, n <= i2.
unsat   1:11s

(* D3: wk1 > 0 \u2014 UNSAT. Not all states have wk1 > 0 (wk1 = 0 allowed). *)
wk1 > 0 :-
    Inv(i1, i2, k, wk1, wk2, s1, s2, n),
    n <= i1, n <= i2.
unsat   40s
*)`.trim();

// Render source with line numbers and syntax highlighting
function renderSource() {
  const lines = sourceCode.split('\n');
  const numEl = document.getElementById('line-nums');
  const codeEl = document.getElementById('source-code');

  let numsHtml = '';
  let codeHtml = '';

  lines.forEach((line, i) => {
    numsHtml += '<span>' + (i + 1) + '</span>';
    codeHtml += highlightLine(escapeHtml(line)) + '\n';
  });

  numEl.innerHTML = numsHtml;
  codeEl.innerHTML = codeHtml;
}

function escapeHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function highlightLine(line) {
  // Comments
  line = line.replace(/(\(\*.*?\*\))/g, '<span class="comment">$1</span>');
  line = line.replace(/(\/\/.*$)/g, '<span class="comment">$1</span>');

  // Predicates
  line = line.replace(/\b(Inv|SchTF|SchFT|SchTT)\b/g, '<span class="predicate">$1</span>');

  // Keywords
  line = line.replace(/\b(and|or|not)\b/g, '<span class="keyword">$1</span>');
  line = line.replace(/(:-)/g, '<span class="keyword">$1</span>');

  // Booleans and types
  line = line.replace(/\b(bool|true|false)\b/g, '<span class="bool">$1</span>');

  // Operators
  line = line.replace(/(&lt;=|&gt;=|&lt;&gt;|&lt;|&gt;)/g, '<span class="operator">$1</span>');

  return line;
}

function copySource() {
  navigator.clipboard.writeText(sourceCode).then(() => {
    const btn = document.querySelector('.copy-btn');
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy to clipboard', 2000);
  });
}

// Initialize
renderSource();
</script>

</body>
</html>
