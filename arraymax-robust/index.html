<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ArrayMax Robustness Verification</title>
<style>
  :root {
    --bg: #ffffff;
    --surface: #f6f8fa;
    --surface2: #eef1f5;
    --border: #d1d9e0;
    --text: #1f2328;
    --text-dim: #656d76;
    --accent: #0969da;
    --accent2: #1a7f37;
    --accent3: #8250df;
    --code-bg: #f6f8fa;
    --tab-hover: #eef1f5;
    --highlight: #0969da1a;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
  }
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 24px 0 0;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .header-content {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 24px;
  }
  .header-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 4px;
  }
  .header-sub {
    color: var(--text-dim);
    font-size: 0.875rem;
    margin-bottom: 16px;
  }
  .tabs {
    display: flex;
    gap: 0;
  }
  .tab {
    padding: 10px 20px;
    cursor: pointer;
    color: var(--text-dim);
    font-size: 0.875rem;
    font-weight: 500;
    border-bottom: 2px solid transparent;
    transition: color 0.15s, border-color 0.15s, background 0.15s;
    user-select: none;
    border-radius: 6px 6px 0 0;
  }
  .tab:hover {
    color: var(--text);
    background: var(--tab-hover);
  }
  .tab.active {
    color: var(--text);
    border-bottom-color: var(--accent);
  }
  .tab .tab-icon { margin-right: 6px; }

  main {
    max-width: 1100px;
    margin: 0 auto;
    padding: 32px 24px 80px;
  }
  .panel { display: none; }
  .panel.active { display: block; }

  /* Markdown-rendered content */
  .content h1 { font-size: 1.75rem; margin: 32px 0 16px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
  .content h1:first-child { margin-top: 0; }
  .content h2 { font-size: 1.375rem; margin: 28px 0 12px; padding-bottom: 6px; border-bottom: 1px solid var(--border); color: var(--accent); }
  .content h3 { font-size: 1.1rem; margin: 20px 0 8px; color: var(--accent3); }
  .content h4 { font-size: 1rem; margin: 16px 0 8px; color: var(--text-dim); }
  .content p { margin: 12px 0; }
  .content strong { color: #1f2328; }
  .content blockquote {
    border-left: 3px solid var(--accent);
    padding: 8px 16px;
    margin: 12px 0;
    background: var(--surface);
    border-radius: 0 6px 6px 0;
    color: var(--text-dim);
  }
  .content ul, .content ol { margin: 8px 0 8px 24px; }
  .content li { margin: 4px 0; }
  .content hr { border: none; border-top: 1px solid var(--border); margin: 24px 0; }
  .content a { color: var(--accent); text-decoration: none; }
  .content a:hover { text-decoration: underline; }
  .content table {
    width: 100%;
    border-collapse: collapse;
    margin: 16px 0;
    font-size: 0.875rem;
  }
  .content table th {
    text-align: left;
    padding: 10px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    font-weight: 600;
    color: var(--accent);
  }
  .content table td {
    padding: 8px 14px;
    border: 1px solid var(--border);
  }
  .content table tr:hover td {
    background: var(--surface);
  }
  .content code {
    font-family: 'SF Mono', 'Fira Code', 'Fira Mono', Menlo, Consolas, monospace;
    background: var(--surface2);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.85em;
    color: var(--accent3);
  }
  .content pre {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px 20px;
    overflow-x: auto;
    margin: 16px 0;
    position: relative;
  }
  .content pre code {
    background: none;
    padding: 0;
    border-radius: 0;
    font-size: 0.8125rem;
    color: var(--text);
    line-height: 1.5;
  }

  /* Source code panel */
  .source-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  .source-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: var(--surface2);
    border-bottom: 1px solid var(--border);
    font-size: 0.8125rem;
    color: var(--text-dim);
  }
  .source-filename {
    font-family: 'SF Mono', Menlo, Consolas, monospace;
    color: var(--text);
    font-weight: 500;
  }
  .source-lines {
    display: flex;
    overflow-x: auto;
    font-family: 'SF Mono', 'Fira Code', Menlo, Consolas, monospace;
    font-size: 0.8125rem;
    line-height: 1.6;
  }
  .line-numbers {
    padding: 16px 0;
    text-align: right;
    color: var(--text-dim);
    user-select: none;
    min-width: 48px;
    opacity: 0.5;
    border-right: 1px solid var(--border);
  }
  .line-numbers span {
    display: block;
    padding: 0 12px;
  }
  .source-code {
    padding: 16px;
    flex: 1;
    white-space: pre;
    color: var(--text);
  }
  .source-code .comment { color: #6a737d; font-style: italic; }
  .source-code .keyword { color: #cf222e; }
  .source-code .predicate { color: #0550ae; }
  .source-code .operator { color: #8250df; }
  .source-code .bool { color: #1a7f37; }
  .source-code .number { color: #953800; }

  /* Copy button */
  .copy-btn {
    background: var(--surface);
    color: var(--text-dim);
    border: 1px solid var(--border);
    padding: 4px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.15s;
  }
  .copy-btn:hover { color: var(--text); background: var(--tab-hover); }

  /* Info boxes */
  .info-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent);
    border-radius: 0 6px 6px 0;
    padding: 16px 20px;
    margin: 20px 0;
  }
  .info-box.success { border-left-color: var(--accent2); }
  .info-box.purple { border-left-color: var(--accent3); }

  /* Top navigation */
  .topnav { border-bottom: 1px solid var(--border); font-size: 0.8rem; }
  .topnav-content {
    max-width: 1100px; margin: 0 auto; padding: 0 24px;
    display: flex; align-items: center; gap: 2px; flex-wrap: wrap;
  }
  .topnav-home {
    color: var(--accent); text-decoration: none; font-weight: 500;
    padding: 8px 0; white-space: nowrap; margin-right: 8px;
  }
  .topnav-home:hover { text-decoration: underline; }
  .nav-group { position: relative; }
  .nav-group-btn {
    background: none; border: none; cursor: pointer;
    color: var(--text-dim); font-size: 0.8rem; padding: 8px 12px;
    border-radius: 4px; font-family: inherit;
    transition: color 0.15s, background 0.15s;
  }
  .nav-group-btn:hover, .nav-group:focus-within .nav-group-btn {
    color: var(--text); background: var(--surface2);
  }
  .nav-group-btn.active { color: var(--text); font-weight: 600; }
  .nav-dropdown {
    display: none; position: absolute; top: 100%; left: 0;
    background: var(--bg); border: 1px solid var(--border);
    border-radius: 6px; padding: 4px 0; min-width: 180px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 200;
  }
  .nav-group:hover .nav-dropdown,
  .nav-group:focus-within .nav-dropdown { display: block; }
  .nav-dropdown a {
    display: block; padding: 6px 16px; color: var(--text-dim);
    text-decoration: none; white-space: nowrap;
    transition: background 0.1s, color 0.1s;
  }
  .nav-dropdown a:hover { background: var(--surface); color: var(--text); }
  .nav-dropdown a.active { color: var(--accent); font-weight: 600; background: var(--highlight); }

  /* Responsive */
  @media (max-width: 768px) {
    .tab { padding: 8px 12px; font-size: 0.8rem; }
    main { padding: 20px 16px 60px; }
    .header-title { font-size: 1.25rem; }
  }
</style>
</head>
<body>

<header>
  <div class="topnav">
    <div class="topnav-content">
      <a href="../" class="topnav-home">&larr; All Examples</a>
      <div class="nav-group">
        <button class="nav-group-btn active">Robustness &#9662;</button>
        <div class="nav-dropdown">
          <a href="../isort/">Insertion Sort</a>
          <a href="../kruskal/">Kruskal</a>
          <a href="../dijk/">Dijkstra</a>
          <a href="../arraymax-robust/" class="active">ArrayMax</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Sensitivity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../histogram/">Histogram</a>
          <a href="../cdf/">CDF</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Monotonicity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../arraymax/">ArrayMax</a>
          <a href="../arraysum/">ArraySum</a>
          <a href="../kruskal-mono/">Kruskal</a>
          <a href="../arraysum-qmono/">ArraySum (Quant.)</a>
          <a href="../dijk-mono/">Dijkstra (vacuous)</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Commutativity &#9662;</button>
        <div class="nav-dropdown">
          <a href="../commutativity/">ArraySum</a>
        </div>
      </div>
      <div class="nav-group">
        <button class="nav-group-btn">Cost &#9662;</button>
        <div class="nav-dropdown">
          <a href="../countpositive/">CountPositive</a>
          <a href="../cost-ext/">Extensions</a>
        </div>
      </div>
    </div>
  </div>
  <div class="header-content">
    <div class="header-title">ArrayMax Robustness Verification</div>
    <div class="header-sub">Relational Cell Morphing with PCSAT &mdash; Constant Bound (K=1) Proof</div>
    <div class="tabs">
      <div class="tab active" data-panel="simple" onclick="switchTab(this)">
        <span class="tab-icon">&#128196;</span>Overview
      </div>
      <div class="tab" data-panel="detailed" onclick="switchTab(this)">
        <span class="tab-icon">&#128214;</span>Detailed Tutorial
      </div>
      <div class="tab" data-panel="source" onclick="switchTab(this)">
        <span class="tab-icon">&#128187;</span>Source Code
      </div>
    </div>
  </div>
</header>

<main>
  <!-- ============ SIMPLE / OVERVIEW PANEL ============ -->
  <div id="panel-simple" class="panel active content">
    <h1>ArrayMax &epsilon;-Robustness Verification with PCSAT</h1>
    <p>A concise tutorial on verifying that the maximum operation does NOT amplify perturbation &mdash; the bound stays constant at &epsilon;.</p>
    <hr>

    <h2>The Algorithm</h2>
<pre><code>ArrayMax(A: array, n: size)
    m := A[0]
    for i = 1 to n-1:
        if A[i] &gt; m:
            m := A[i]
    return m</code></pre>

    <h2>The Property</h2>
    <div class="info-box">
      <strong>&epsilon;-Robustness (K = 1, constant bound):</strong><br>
      &forall;i. |A1[i] &minus; A2[i]| &le; &epsilon; &rArr; |max(A1) &minus; max(A2)| &le; &epsilon;
    </div>
    <p>ArrayMax and insertion sort are <strong>contractive</strong> &mdash; they do not amplify noise. Compare:</p>
    <table>
      <tr><th>Algorithm</th><th>K (amplification)</th></tr>
      <tr><td>ArraySum</td><td>n (amplifies by factor n)</td></tr>
      <tr><td>Kruskal MST</td><td>N&minus;1</td></tr>
      <tr><td>Dijkstra SP</td><td>N&minus;1</td></tr>
      <tr><td>Insertion Sort</td><td>1 (no amplification)</td></tr>
      <tr><td><strong>ArrayMax</strong></td><td><strong>1 (no amplification!)</strong></td></tr>
    </table>

    <h2>Why K = 1?</h2>
    <p>The key fact: <code>max</code> is 1-Lipschitz in L&infin; norm. It <em>selects</em> one element rather than accumulating all of them.</p>
<pre><code>Let j be the index where A1 achieves its max: max(A1) = A1[j].

max(A1) = A1[j]
        &le; A2[j] + &epsilon;       (since |A1[j] - A2[j]| &le; &epsilon;)
        &le; max(A2) + &epsilon;      (since A2[j] &le; max(A2))

So: max(A1) - max(A2) &le; &epsilon;.  By symmetry: |max(A1) - max(A2)| &le; &epsilon;.  QED.</code></pre>

    <h2>Cell Morphing Setup</h2>
    <p><strong>10 variables</strong> with 2 sign bits (<code>bk</code>, <code>bm</code>) since it's two-sided robustness.</p>
    <table>
      <tr><th>Variable</th><th>Meaning</th><th>Changes?</th></tr>
      <tr><td><code>i</code></td><td>Current element index</td><td>Yes (0 &rarr; n)</td></tr>
      <tr><td><code>k</code></td><td>Distinguished element index</td><td>Never</td></tr>
      <tr><td><code>wk1, wk2</code></td><td>A1[k], A2[k]</td><td>Never</td></tr>
      <tr><td><code>bk</code></td><td>Input sign bit</td><td>Never</td></tr>
      <tr><td><code>m1, m2</code></td><td>Running max in run 1, run 2</td><td>Yes (non-decreasing)</td></tr>
      <tr><td><code>bm</code></td><td>Output sign bit</td><td>Yes</td></tr>
      <tr><td><code>n, eps</code></td><td>Array size, perturbation bound</td><td>Never</td></tr>
    </table>

    <h2>The Key Difference: Constant Bound</h2>
    <div class="info-box success">
      <strong>Epsilon bound is CONSTANT:</strong> <code>|m1' - m2'| &le; &epsilon;</code> (not <code>i'&middot;&epsilon;</code>).<br>
      The bound never grows &mdash; this forces the solver to verify that <code>max</code> preserves the bound at every step.
    </div>

    <h2>Verification Results</h2>
    <table>
      <tr><th>Goal</th><th>Result</th><th>Meaning</th></tr>
      <tr><td><code>m1-m2 &gt; eps or m2-m1 &gt; eps</code></td><td><strong>UNSAT</strong></td><td>&epsilon;-robustness VERIFIED</td></tr>
      <tr><td><code>m1-m2 &le; eps and m2-m1 &le; eps</code></td><td><strong>SAT</strong></td><td>Bound achievable (tight)</td></tr>
    </table>
  </div>

  <!-- ============ DETAILED TUTORIAL PANEL ============ -->
  <div id="panel-detailed" class="panel content">
    <h1>ArrayMax Robustness: Constant Bound Verification</h1>
    <p>A detailed tutorial demonstrating that the maximum operation is 1-robust &mdash; it does NOT amplify perturbation, unlike summation which amplifies by a factor of n.</p>
    <hr>

    <h2>Part 1: The Property &mdash; Constant Robustness</h2>
<pre><code>PROPERTY: &epsilon;-Robustness (K = 1, constant bound)

&forall;i. |A1[i] - A2[i]| &le; &epsilon;  &rArr;  |max(A1) - max(A2)| &le; &epsilon;
    ~~~~~~~~~~~~~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~
    INPUT: L&infin; perturbation     OUTPUT: bounded by SAME &epsilon;</code></pre>

    <h3>Why Is This Remarkable?</h3>
    <p>Compare the robustness bounds across algorithms:</p>
<pre><code>ArraySum:       K = n     (amplifies perturbation by factor n)
Kruskal MST:    K = N-1   (amplifies by factor N-1)
Dijkstra SP:    K = N-1   (amplifies by factor N-1)
Insertion Sort: K = 1     (no amplification)
ArrayMax:       K = 1     (no amplification!)</code></pre>
    <p>ArrayMax and insertion sort are <strong>contractive</strong> &mdash; they do not amplify noise. ArraySum and graph algorithms amplify linearly.</p>

    <h3>Why K = 1? (Informal Proof)</h3>
    <p>The key fact: <code>max</code> is 1-Lipschitz in L&infin; norm.</p>
<pre><code>Let j be the index where A1 achieves its max: max(A1) = A1[j].

max(A1) = A1[j]
        &le; A2[j] + &epsilon;       (since |A1[j] - A2[j]| &le; &epsilon;)
        &le; max(A2) + &epsilon;      (since A2[j] &le; max(A2))

So: max(A1) - max(A2) &le; &epsilon;.
By symmetry: max(A2) - max(A1) &le; &epsilon;.
Therefore: |max(A1) - max(A2)| &le; &epsilon;.  QED.</code></pre>
    <p>The crucial step: the maximum <em>selects</em> one element &mdash; it doesn't accumulate all of them. Selection doesn't amplify; accumulation does.</p>

    <h3>Example</h3>
<pre><code>&epsilon; = 2

A1 = [3, 1, 7, 2, 5]    &rarr;  max(A1) = 7
A2 = [4, 3, 9, 2, 6]    &rarr;  max(A2) = 9

Per-element: |3-4|=1, |1-3|=2, |7-9|=2, |2-2|=0, |5-6|=1  (all &le; 2 &#10003;)
Output: |7 - 9| = 2 &le; &epsilon; = 2  &#10003;</code></pre>
    <hr>

    <h2>Part 2: How This Differs from Other Robustness Encodings</h2>
    <p>The epsilon bound in previous robustness encodings <strong>grows with iterations</strong>:</p>
<pre><code>Kruskal:  |c1' - c2'| &le; i' &middot; &epsilon;       (grows linearly)
Dijkstra: |dv1' - dv2'| &le; h' &middot; &epsilon;     (grows with hop count)</code></pre>
    <p>For ArrayMax, the bound is <strong>constant</strong>:</p>
<pre><code>ArrayMax: |m1' - m2'| &le; &epsilon;             (never grows!)</code></pre>
    <p>This is a fundamentally different invariant. The solver must verify that the branching <code>max</code> operation preserves the constant bound at every step &mdash; not just that a growing bound stays valid.</p>
    <hr>

    <h2>Part 3: Relational Cell Morphing Setup</h2>
<pre><code>&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
&#9474;                  TWO DISTINGUISHED CELLS                &#9474;
&#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;
&#9474;                                                          &#9474;
&#9474;  1. INPUT CELL (Array Element)                           &#9474;
&#9474;     k, wk1, wk2, bk &mdash; NEVER CHANGE                     &#9474;
&#9474;     PRECONDITION: |wk1 - wk2| &le; &epsilon;                     &#9474;
&#9474;                                                          &#9474;
&#9474;  2. OUTPUT CELL (Running Maximum)                        &#9474;
&#9474;     m1, m2, bm &mdash; CAN CHANGE (non-decreasing)            &#9474;
&#9474;     POSTCONDITION: |m1 - m2| &le; &epsilon; (CONSTANT!)           &#9474;
&#9474;                                                          &#9474;
&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;</code></pre>

    <h3>State Variables</h3>
    <table>
      <tr><th>Variable</th><th>Type</th><th>Meaning</th><th>Changes?</th></tr>
      <tr><td><code>i</code></td><td>int</td><td>Current element index</td><td>Yes (0 &rarr; n)</td></tr>
      <tr><td><code>k</code></td><td>int</td><td>Distinguished element index</td><td>Never</td></tr>
      <tr><td><code>wk1</code></td><td>real</td><td>A1[k]</td><td>Never</td></tr>
      <tr><td><code>wk2</code></td><td>real</td><td>A2[k]</td><td>Never</td></tr>
      <tr><td><code>bk</code></td><td>bool</td><td>Input sign bit</td><td>Never</td></tr>
      <tr><td><code>m1</code></td><td>real</td><td>Running max in run 1</td><td>Yes (non-decreasing)</td></tr>
      <tr><td><code>m2</code></td><td>real</td><td>Running max in run 2</td><td>Yes (non-decreasing)</td></tr>
      <tr><td><code>bm</code></td><td>bool</td><td>Output sign bit</td><td>Yes</td></tr>
      <tr><td><code>n</code></td><td>int</td><td>Array size</td><td>Never</td></tr>
      <tr><td><code>eps</code></td><td>real</td><td>Perturbation bound</td><td>Never</td></tr>
    </table>
    <p><strong>10 variables</strong> (same as insertion sort robustness). Sign bits are back because this is two-sided robustness.</p>
    <hr>

    <h2>Part 4: Initialization</h2>
<pre><code>Inv(i, k, wk1, wk2, bk:bool, m1, m2, bm:bool, n, eps) :-
    i = 0,
    n &gt; 0,
    0 &le; k, k &lt; n,
    0 &le; eps,
    (* Input precondition: |wk1 - wk2| &le; eps *)
    (bk and 0 &le; wk2 - wk1 and wk2 - wk1 &le; eps) or
    (!bk and 0 &le; wk1 - wk2 and wk1 - wk2 &le; eps),
    0 &le; wk1, 0 &le; wk2,
    m1 = 0, m2 = 0.</code></pre>
    <p>Standard sign-bit encoding for the input precondition. Both maxima start at 0.</p>
    <hr>

    <h2>Part 5: Transition</h2>
<pre><code>Inv(i', k, wk1, wk2, bk:bool, m1', m2', bm':bool, n, eps) :-
    Inv(i, k, wk1, wk2, bk:bool, m1, m2, bm:bool, n, eps),
    (
        (* HIT: process distinguished element k *)
        i &lt; n and i = k and i' = i + 1 and
        ((m1 &ge; wk1 and m1' = m1) or (wk1 &gt; m1 and m1' = wk1)) and
        ((m2 &ge; wk2 and m2' = m2) or (wk2 &gt; m2 and m2' = wk2))
    ) or (
        (* MISS: process other element &mdash; unknown but bounded *)
        i &lt; n and i &ne; k and i' = i + 1 and
        m1' &ge; m1 and m2' &ge; m2
    ) or (
        (* Finished: stutter *)
        i &ge; n and i' = i and m1' = m1 and m2' = m2
    ),
    (* EPSILON BOUND &mdash; CONSTANT, not i'*eps! *)
    (bm' and 0 &le; m2' - m1' and m2' - m1' &le; eps) or
    (!bm' and 0 &le; m1' - m2' and m1' - m2' &le; eps).</code></pre>

    <h3>HIT Case Analysis (4 sub-cases)</h3>
    <table>
      <tr><th>Sub-case</th><th>Result</th><th>|m1' - m2'| &le; &epsilon; why?</th></tr>
      <tr><td>m1&ge;wk1 and m2&ge;wk2</td><td>m1'=m1, m2'=m2</td><td>|m1-m2| &le; &epsilon; (invariant)</td></tr>
      <tr><td>m1&ge;wk1 and wk2&gt;m2</td><td>m1'=m1, m2'=wk2</td><td>wk2 &le; wk1+&epsilon; &le; m1+&epsilon;, so m2'-m1' &le; &epsilon;</td></tr>
      <tr><td>wk1&gt;m1 and m2&ge;wk2</td><td>m1'=wk1, m2'=m2</td><td>symmetric to above</td></tr>
      <tr><td>wk1&gt;m1 and wk2&gt;m2</td><td>m1'=wk1, m2'=wk2</td><td>|wk1-wk2| &le; &epsilon; (precondition)</td></tr>
    </table>
    <hr>

    <h2>Part 6: Goal</h2>
<pre><code>m1 - m2 &gt; eps or m2 - m1 &gt; eps :-
    Inv(i, k, wk1, wk2, bk:bool, m1, m2, bm:bool, n, eps),
    n &le; i.</code></pre>
    <p>UNSAT means <code>|max(A1) - max(A2)| &le; &epsilon;</code> for all arrays and all choices of k.</p>
    <hr>

    <h2>Key Takeaways</h2>
    <ol>
      <li><strong>Max is 1-Lipschitz</strong>: It does not amplify perturbation. <code>max</code> selects one element rather than accumulating all of them.</li>
      <li><strong>Constant epsilon bound</strong>: <code>|m1'-m2'| &le; &epsilon;</code> instead of <code>|c1'-c2'| &le; i'&middot;&epsilon;</code>. The bound never grows.</li>
      <li><strong>Contraction relative to sum</strong>: ArraySum amplifies by n, ArrayMax does not.</li>
      <li><strong>Sign bits return</strong>: Unlike monotonicity (one-sided), robustness is two-sided &mdash; <code>bk:bool</code> and <code>bm:bool</code> are needed.</li>
      <li><strong>Branching HIT</strong>: The 4 sub-cases of max &times; max are the main verification challenge.</li>
    </ol>

    <div class="info-box success">
      <strong>Verified:</strong> UNSAT for &epsilon;-violation (K=1 robustness). The bound is tight (SAT confirms achievability).
    </div>
  </div>

  <!-- ============ SOURCE CODE PANEL ============ -->
  <div id="panel-source" class="panel">
    <div class="source-container">
      <div class="source-header">
        <span class="source-filename">robustness_arraymax.clp</span>
        <button class="copy-btn" onclick="copySource()">Copy to clipboard</button>
      </div>
      <div class="source-lines">
        <div class="line-numbers" id="line-nums"></div>
        <div class="source-code" id="source-code"></div>
      </div>
    </div>
  </div>
</main>

<script>
// Tab switching
function switchTab(el) {
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('panel-' + el.dataset.panel).classList.add('active');
}

// Source code content
const sourceCode = `(*
ArrayMax(A: array, n: size)
    m := A[0]
    for i = 1 to n-1:
        if A[i] > m:
            m := A[i]
    return m
*)

(*
PROPERTY: ε-Robustness (constant bound, no growth with n)
  forall i. |A1[i] - A2[i]| <= eps  ==>  |max(A1) - max(A2)| <= eps

This is K=1 robustness: the max operation does NOT amplify perturbation.
Compare with ArraySum which gives K=n (sum amplifies by factor n).

State: i, k, wk1, wk2, bk:bool, m1, m2, bm:bool, n, eps  (10 variables)
*)


(******************************************************************************)
(* INITIALIZATION                                                             *)
(******************************************************************************)

Inv(i, k, wk1, wk2, bk:bool, m1, m2, bm:bool, n, eps) :-
    i = 0,
    n > 0,
    0 <= k, k < n,
    0 <= eps,
    (* Input precondition: |wk1 - wk2| <= eps *)
    (bk and 0 <= wk2 - wk1 and wk2 - wk1 <= eps) or
    (!bk and 0 <= wk1 - wk2 and wk1 - wk2 <= eps),
    (* Non-negative values *)
    0 <= wk1,
    0 <= wk2,
    (* Initial max: both start at 0 *)
    m1 = 0, m2 = 0.


(******************************************************************************)
(* TRANSITION (synchronized)                                                  *)
(******************************************************************************)

Inv(i', k, wk1, wk2, bk:bool, m1', m2', bm':bool, n, eps) :-
    Inv(i, k, wk1, wk2, bk:bool, m1, m2, bm:bool, n, eps),
    (
        (* HIT: process distinguished element k *)
        (* m1' = max(m1, wk1), m2' = max(m2, wk2) — 4 sub-cases *)
        i < n and i = k and i' = i + 1 and
        ((m1 >= wk1 and m1' = m1) or (wk1 > m1 and m1' = wk1)) and
        ((m2 >= wk2 and m2' = m2) or (wk2 > m2 and m2' = wk2))
    ) or (
        (* MISS: process other element — unknown but bounded *)
        i < n and i <> k and i' = i + 1 and
        m1' >= m1 and m2' >= m2
    ) or (
        (* Finished: stutter *)
        i >= n and i' = i and m1' = m1 and m2' = m2
    ),
    (* EPSILON BOUND — CONSTANT, not growing! *)
    (bm' and 0 <= m2' - m1' and m2' - m1' <= eps) or
    (!bm' and 0 <= m1' - m2' and m1' - m2' <= eps).


(******************************************************************************)
(* GOAL: Robustness violation                                                 *)
(*                                                                            *)
(* UNSAT = |max(A1) - max(A2)| <= eps VERIFIED (1-robust)                    *)
(******************************************************************************)

m1 - m2 > eps or m2 - m1 > eps :-
    Inv(i, k, wk1, wk2, bk:bool, m1, m2, bm:bool, n, eps),
    n <= i.`.trim();

// Render source with line numbers and syntax highlighting
function renderSource() {
  const lines = sourceCode.split('\\n');
  const numEl = document.getElementById('line-nums');
  const codeEl = document.getElementById('source-code');

  let numsHtml = '';
  let codeHtml = '';

  lines.forEach((line, i) => {
    numsHtml += '<span>' + (i + 1) + '</span>';
    codeHtml += highlightLine(escapeHtml(line)) + '\\n';
  });

  numEl.innerHTML = numsHtml;
  codeEl.innerHTML = codeHtml;
}

function escapeHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function highlightLine(line) {
  line = line.replace(/(\\(\\*.*?\\*\\))/g, '<span class="comment">$1</span>');
  line = line.replace(/(\/\/.*$)/g, '<span class="comment">$1</span>');
  line = line.replace(/\\b(Inv|SchTF|SchFT|SchTT)\\b/g, '<span class="predicate">$1</span>');
  line = line.replace(/\\b(and|or|not)\\b/g, '<span class="keyword">$1</span>');
  line = line.replace(/(:-)/g, '<span class="keyword">$1</span>');
  line = line.replace(/\\b(bool|true|false)\\b/g, '<span class="bool">$1</span>');
  line = line.replace(/(&lt;=|&gt;=|&lt;&gt;|&lt;|&gt;)/g, '<span class="operator">$1</span>');
  return line;
}

function copySource() {
  navigator.clipboard.writeText(sourceCode).then(() => {
    const btn = document.querySelector('.copy-btn');
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy to clipboard', 2000);
  });
}

// Initialize
renderSource();
</script>
</body>
</html>
